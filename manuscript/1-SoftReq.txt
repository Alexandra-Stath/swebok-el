{mainmatter}

# Απαιτήσεις λογισμικού {#softreq}

## **Ακρωνύμια**

|ATDD   |Acceptance Test Driven Development |
|BDD    |Behavior Driven Development |
|CIA    |Confidentiality, Integrity, and Availability |
|FSM    |Functional Size Measurement |
|INCOSE |International Council on Systems Engineering |
|JAD    |Joint Application Development |
|JRP    |Joint Requirements Planning |
|RUP    |Rational Unified Process |
|SME    |Subject Matter Expert |
|SysML  |Systems Modeling Language |
|TDD    |Test Driven Development |
|UML	|Unified Modeling Language |

## **Εισαγωγή**

Οι απαιτήσεις λογισμικού θα πρέπει να εξετάζονται από δύο οπτικές.
Η πρώτη είναι ως έκφραση των αναγκών και περιορισμών ενός προϊόντος ή έργου
λογισμικού που συντελούν στην επίλυση ενός προβλήματος στον πραγματικό κόσμο.
Δεύτερη είναι εκείνη των δραστηριοτήτων που είναι απαραίτητες για την
ανάπτυξη και τη διατήρηση των απαιτήσεων για ένα προϊόν λογισμικού και για το
έργο που το κατασκευάζει.
Και οι δύο αυτές οπτικές παρουσιάζονται σε αυτό το γνωστικό πεδίο.

Εάν μια ομάδα δεν εκτελέσει καλά τον προσδιορισμό των απαιτήσεων, το έργο, το προϊόν
ή και τα δύο είναι πιθανό να υποστούν επιπλέον κόστη, καθυστερήσεις,
ακυρώσεις και ελαττώματα. Ένας λόγος είναι ότι κάθε απαίτηση προϊόντος λογισμικού
οδηγεί γενικά σε πολλές αποφάσεις σχεδιασμού.
Κάθε απόφαση σχεδίασης οδηγεί συνήθως σε πολλές αποφάσεις σε επίπεδο κώδικα.
Επίσης, κάθε απόφαση μπορεί να εμπεριέχει αρκετές δοκιμαστικές αποφάσεις.
Με άλλα λόγια, ο σωστός καθορισμός των απαιτήσεων είναι μια δουλειά υψηλού κινδύνου.
Αν δεν ανιχνευθούν και διορθωθούν έγκαιρα, απαιτήσεις που λείπουν,
έχουν παρερμηνευτεί ή είναι λανθασμένες μπορούν να προκαλέσουν εκθετικής φύσεως εργασίες
αναθεώρησης για να διορθωθούν.

Τα σχέδια λογισμικού στον πραγματικό κόσμο τείνουν να αντιμετωπίζουν δύο βασικά
προβλήματα που σχετίζονται με τις απαιτήσεις:
1. ατέλεια: υπάρχουν απαιτήσεις ενδιαφερόμενων μερών που δεν αποκαλύπτονται και
δεν επικοινωνούνται στους μηχανικούς λογισμικού,
2. ασάφεια: οι απαιτήσεις επικοινωνούνται με τρόπο που επιδέχεται
πολλαπλές ερμηνείες, με μόνο μια απο αυτές να είναι η σωστή.

Πέρα από τον προφανή, βραχυπρόθεσμο, ρόλο που έχουν οι απαιτήσεις στην αρχική κατασκευή
λογισμικού, παίζουν επίσης έναν λιγότερο αναγνωρισμένο, αλλά εξίσου σημαντικό
ρόλο στη μακροπρόθεσμη συντήρησή του. Όταν ένας μηχανικός λογισμικού λαμβάνει
λογισμικό χωρίς καμία υποστηρικτική τεκμηρίωση, έχει αρκετά μέσα για να καθορίσει
τι κάνει αυτός ο κώδικας, όπως να τον εκτελέσει, να τον περάσει από έναν αποσφαλματωτή,
να τον εκτελέσει χειροκίνητα, να τον αναλύσει στατικά, κλπ.
Η πρόκληση είναι να καθοριστεί τι ακριβώς είναι αυτός ο κώδικας *προορισμένος να κάνει*.
Αυτό που συνήθως αναφέρεται ως *σφάλμα* - αλλά καλύτερα αποκαλείται *ελάττωμα* - είναι
απλώς μια παρατηρήσιμη διαφορά μεταξύ αυτού που προορίζεται να κάνει το λογισμικό
και αυτού που πραγματικά κάνει. Ο ρόλος της τεκμηρίωσης των απαιτήσεων κατά τη
διάρκεια του κύκλου ζωής του λογισμικού είναι να καταγράψει και να επικοινωνήσει τις
προθέσεις στους μηχανικούς λογισμικού που συντηρούν τον κώδικα αλλά μπορεί
να μην είναι οι αρχικοί του συντάκτες.

Το γνωστικό πεδίο των Απαιτήσεων Λογισμικού αφορά την ανάπτυξη των απαιτήσεων
λογισμικού και τη διαχείρισή τους κατά τη διάρκεια της ζωής του λογισμικού.
Αυτό το γνωστικό πεδίο παρέχει κατανόηση ότι οι απαιτήσεις λογισμικού:

* δεν είναι απαραίτητα μια διακριτή δραστηριότητα στο μπροστινό άκρο του κύκλου ζωής
ανάπτυξης λογισμικού, αλλά μια διαδικασία που ξεκινά στην αρχή ενός έργου και συχνά
συνεχίζεται να επανεκτιμάται καθ' όλη τη διάρκεια της ζωής του λογισμικού.
* χρειάζεται να προσαρμόζονται στο περιβάλλον και στα πλαίσια του οργανισμού και του έργου.

Ο όρος *απαιτήσεις μηχανικής* χρησιμοποιείται ευρέως στο χώρο για
να υποδηλώσει τη συστηματική διαχείριση των απαιτήσεων.
Για λόγους συνέπειας, ο όρος *μηχανική* θα χρησιμοποιηθεί σε αυτό
το γνωστικό πεδίο αποκλειστικά για την τεχνολογία λογισμικού.

Το γνωστικό πεδίο των Απαιτήσεων Λογισμικού σχετίζεται στενά με τα γνωστικά πεδία
της Αρχιτεκτονικής Λογισμικού, του Σχεδιασμού Λογισμικού, της Κατασκευής Λογισμικού,
του Ελέγχου Λογισμικού και της Συντήρησης Λογισμικού. Σχετίζεται, ακόμα, με τον κλάδο
της μοντελοποίησης στο γνωστικό πεδίο των Μοντέλων και Μεθόδων Τεχνολογίας Λογισμικού,
καθώς ο καθορισμός απαιτήσεων υπό τη μορφή μοντέλων μπορεί να προσφέρει σημαντική αξία.

Αυτό το γνωστικό πεδίο σχετίζεται ακόμα, με το θέμα του Κύκλου Ζωής Λογισμικού που συμπεριλαμβάνεται
στο γνωστικό πεδίο των Διεργασιών Τεχνολογίας Λογισμικού, καθώς αυτό επικεντρώνεται
στο πως και το ποια δουλειά που σχετίζεται με τις απαιτήσεις, μπορεί και πρέπει
να γίνει, ενώ ο κύκλος ζωής του έργου καθορίζει το πότε θα γίνει αυτή η εργασία.
Για παράδειγμα, σε έναν κύκλο ζωής ενός έργου που ακολουθεί το μοντέλο του καταρράκτη,
όλη η εργασία των απαιτήσεων γίνεται ουσιαστικά σε μια διακριτή φάση απαιτήσεων και
αναμένεται να είναι ολοκληρωμένη σε σημαντικό βαθμό πριν οποιαδήποτε διεργασία
αρχιτεκτονικής, σχεδιασμού και κατασκευής προκύψει σε επόμενες φάσεις.
Σε μερικούς επαναλαμβανόμενους κύκλους ζωής, η αρχική, υψηλού επιπέδου εργασία
απαιτήσεων γίνεται κατά τη διάρκεια μιας φάσης έναρξης, και περαιτέρω λεπτομερείς
πληροφορίες δίνονται κατά τη διάρκεια μίας ή περισσότερων φάσεων επεξήγησης.
Σε έναν ευέλικτο (Agile) κύκλο ζωής, η εργασία πάνω στις απαιτήσεις γίνεται σταδιακά,
καθώς κατασκευάζεται κάθε επιπλέον στοιχείο λειτουργικότητας.

Τα τι και πως της εργασίας απαιτήσεων λογισμικού σε ένα έργο πρέπει να
καθορίζονται από τη φύση του κατασκευαζόμενου λογισμικού, όχι από
τον κύκλο ζωής κάτω από τον οποίο κατασκευάζεται.
Όσον αφορά την τεκμηρίωση των απαιτήσεων, καθώς αυτή απαθανατίζει και επικοινωνεί
την πρόθεση του λογισμικού, οι μεταγενέστεροι συντηρητές δεν πρέπει να μπορούν να
αναγνωρίσουν τον κύκλο ζωής που χρησιμοποιήθηκε στην προηγούμενη ανάπτυξη μόνο
από τη μορφή αυτών των απαιτήσεων.

Αυτό το γνωστικό πεδίο σχετίζεται επίσης, αλλά κάπως λιγότερο, με τα γνωστικά πεδία
της Διαχείρισης Σχηματισμών Λογισμικού, της Διοίκησης Τεχνολογίας Λογισμικού
και της Ποιότητας Λογισμικού. Οι προσεγγίσεις διαχείρισης σχηματισμών λογισμικού
μπορούν να εφαρμοστούν για την ανίχνευση και διαχείριση των απαιτήσεων, καθώς
η Ποιότητα Λογισμικού εξετάζει πόσο καλά διαμορφώνονται οι απαιτήσεις και η
Διοίκηση Τεχνολογίας Λογισμικού μπορεί να χρησιμοποιήσει την κατάσταση των
απαιτήσεων για να αξιολογήσει την ολοκλήρωση του έργου.

## **Κατανομή των θεμάτων για τις απαιτήσεις λογισμικού**

{id="fig-softreq-tree"}
![Σχήμα 1.1 Κατανομή των θεμάτων στο γνωστικό πεδίο Απαιτήσεις λογισμικού.](images/1-SoftReq.png)

Η κατανομή των θεμάτων για το γνωστικό πεδίο των απαιτήσεων λογισμικού
απεικονίζεται στο [Σχήμα 1.1](#fig-softreq-tree).

## **Βασικές αρχές στις απαιτήσεις λογισμικού**

### *Ορισμός μιας απαίτησης λογισμικού*

Επισήμως, μια απαίτηση λογισμικού έχει οριστεί ως:

* μια προϋπόθεση ή δυνατότητα που χρειάζεται ένας χρήστης
προκειμένου να επιλύσει ένα πρόβλημα ή να επιτύχει έναν στόχο
* μια προϋπόθεση ή δυνατότητα που πρέπει να πληροί ή να διαθέτει
ένα σύστημα ή ένα συστατικό αυτού, προκειμένου να ικανοποιεί ένα
συμβόλαιο, ένα πρότυπο, μια προδιαγραφή ή ένα άλλο επίσημα
επιβεβλημένο έγγραφο.
* μια τεκμηριωμένη αναπαράσταση ή ικανότητα όπως αναφέρεται
στο (1) ή (2) παραπάνω.


Αυτός ο επίσημος ορισμός επεκτείνεται σε αυτό το γνωστικό πεδίο,
περιλαμβάνοντας εκφράσεις των αναγκών και περιορισμών ενός έργου λογισμικού.

Ουσιαστικά, μια απαίτηση λογισμικού είναι μια ιδιότητα που πρέπει
να εξεταστεί με βάση κάποιο χαρακτηριστικό, ώστε να λύνει κάποιο πρόβλημα
στον πραγματικό κόσμο. Μπορεί να έχει ως σκοπό να αυτοματοποιήσει
ολόκληρη ή μέρος μιας εργασίας που υποστηρίζει τις επιχειρηματικές
πολιτικές και διαδικασίες ενός οργανισμού, να διορθώσει ελλείψεις
υπάρχοντος λογισμικού ή να ελέγξει μια συσκευή -- ονοματίζοντας μόνο κάποια
από τα πολλά προβλήματα για τα οποία είναι δυνατόν να υπάρξουν λύσεις λογισμικού.

Οι επιχειρησιακές πολιτικές και διαδικασίες, καθώς και οι λειτουργίες των
συσκευών είναι συχνά πολύπλοκες. Κατ' επέκταση, οι απαιτήσεις λογισμικού είναι
συνήθως ένας πολύπλοκος συνδυασμός απαιτήσεων από διάφορους ενδιαφερόμενους
φορείς σε διαφορετικά οργανωτικά επίπεδα, οι οποίοι είναι εμπλεκόμενοι ή
συνδεδεμένοι με κάποιο πτυχή του περιβάλλοντος στο οποίο θα λειτουργήσει
το λογισμικό.

Οι πελάτες και οι χρήστες συνήθως επιβάλλουν απαιτήσεις.
Ωστόσο, άλλοι τρίτοι φορείς, όπως οι ρυθμιστικές αρχές και σε ορισμένες
περιπτώσεις, ο οργανισμός του λογισμικού ή το ίδιο το έργο, ενδέχεται επίσης
να επιβάλουν απαιτήσεις.

### *Κατηγορίες Απαιτήσεων Λογισμικού*

Στο σχήμα 1.2 φαίνονται οι κατηγορίες απαιτήσεων λογισμικού που
προσδιορίζονται στο συγκεκριμένο γνωστικό πεδίο, σε συνδυασμό με τις σχέσεις
ανάμεσα σε αυτές τις κατηγορίες. Κάθε κατηγορία περιγράφεται περαιτέρω παρακάτω.

### *Απαιτήσεις προϊόντος λογισμικού και απαιτήσεις έργου λογισμικού*

Οι απαιτήσεις προϊόντος λογισμικού προσδιορίζουν την αναμενόμενη μορφή, εφαρμογή ή
λειτουργία του λογισμικού. Οι απαιτήσεις έργου λογισμικού - επίσης ονομαζόμενες
απαιτήσεις διεργασίας ανάπτυξης ή, μερικές φορές, επιχειρηματικές απαιτήσεις -
περιορίζουν το έργο που κατασκευάζει το λογισμικό. Οι απαιτήσεις έργου
περιορίζουν συνήθως το κόστος, το χρονοδιάγραμμα ή/και το προσωπικό, αλλά
μπορεί επίσης να περιορίζουν άλλες πτυχές ενός έργου λογισμικού, όπως τα
περιβάλλοντα ελέγχου, τη μεταφορά δεδομένων, την εκπαίδευση χρηστών και την
συντήρηση. Οι απαιτήσεις έργου λογισμικού μπορούν να καταγραφούν σε έναν χάρτη
έργου ή σε ένα άλλο, υψηλού επιπέδου, έγγραφο έναρξης έργου. Σχετίζονται
περισσότερο με τον τρόπο διοίκησης του έργου ή την επιλογή διαδικασίας κύκλου
ζωής που πρέπει να χρησιμοποιηθεί. Αυτό το γνωστικό πεδίο δεν παρουσιάζει
περαιτέρω τις απαιτήσεις έργου λογισμικού.

![Σχήμα 1.2 Κατηγορίες Απαιτήσεων Λογισμικού.](images/.png)

### *Λειτουργικές απαιτήσεις*

Οι λειτουργικές απαιτήσεις καθορίζουν τις παρατηρήσιμες συμπεριφορές που πρέπει
να παρέχει το λογισμικό - πολιτικές που πρέπει να επιβάλλονται και διαδικασίες που
πρέπει να πραγματοποιούνται. Παραδείγματα πολιτικών στο λογισμικό τραπεζικής χρήσης
μπορεί να είναι «ένας λογαριασμός πρέπει πάντα να έχει τουλάχιστον έναν πελάτη ως
ιδιοκτήτη του», και «το υπόλοιπο σε έναν λογαριασμό δεν πρέπει ποτέ να είναι αρνητικό».
Παραδείγματα διαδικασιών μπορεί να καθορίζουν το νόημα της κατάθεσης χρημάτων σε έναν
λογαριασμό, της ανάληψης χρημάτων από έναν λογαριασμό και της μεταφοράς χρημάτων από
έναν λογαριασμό σε άλλον.

Ακόμη και το πιο τεχνικό (μη επιχειρησιακού προσανατολισμού) λογισμικό, όπως το
λογισμικό που υλοποιεί το πρωτόκολλο επικοινωνίας δικτύου Ελέγχου
Μετάδοσης/Πρωτοκόλλου Διαδικτύου (TCP/IP), έχει πολιτικές και διαδικασίες:
"μια θύρα θα πρέπει να μπορεί να υπάρχει με καμία, μία ή πολλές σχετικές
συνδέσεις, αλλά μία σύνδεση θα πρέπει να υπάρχει σε ακριβώς μία συσχετισμένη θύρα",
"οι αποδεκτές καταστάσεις μιας σύνδεσης θα πρέπει να είναι «ακρόαση»,
«syn sent», «εγκαθίδρυση», «κλείσιμο», ..." και "εάν ο χρόνος ζωής
ενός Τμήματος φτάσει στο μηδέν, αυτό το Τμήμα θα διαγραφεί".

### *Μη λειτουργικές απαιτήσεις*

Οι μη λειτουργικές απαιτήσεις περιορίζουν κατά κάποιον τρόπο τις τεχνολογίες
που πρέπει να χρησιμοποιηθούν κατά την υλοποίηση. Προκύπτουν, λοιπόν, ερωτήματα
όπως: Ποιες υπολογιστικές πλατφόρμες θα χρησιμοποιηθούν; Ποια ή ποιες μηχανές
βάσεων δεδομένων; Πόσο ακριβή θα πρέπει να είναι τα δεδομένα; Με ποια ταχύτητα
θα πρέπει να παρουσιάζονται τα αποτελέσματα; Πόσες εγγραφές ενός συγκεκριμένου
τύπου που πρέπει να αποθηκευτούν; Ορισμένες μη λειτουργικές απαιτήσεις μπορεί
να αναφέρονται στη λειτουργία του λογισμικού.

Οι μη λειτουργικές απαιτήσεις μπορούν να χωριστούν περαιτέρω σε περιορισμούς
τεχνολογίας και περιορισμούς ποιότητας υπηρεσιών.

### *Περιορισμοί τεχνολογίας*

Αυτές οι απαιτήσεις επιβάλλουν - ή απαγορεύουν - τη χρήση συγκεκριμένων
τεχνολογιών αυτοματισμού με συγκεκριμένα ονόματα ή ορισμένες υποδομές.
Παραδείγματα αυτών των απαιτήσεων είναι η απαίτηση για τη χρήση συγκεκριμένων
υπολογιστικών πλατφορμών (π.χ. Windows™, MacOS™, Android OS™, iOS™), γλωσσών
προγραμματισμού (π.χ. Java, C++, C#, Python), συμβατότητας με συγκεκριμένους
περιηγητές ιστού (π.χ. Chrome™, Safari™, Edge™), συγκεκριμένες μηχανές βάσεων
δεδομένων (π.χ. Oracle™, SQL Server™, MySQL™) και γενικές τεχνολογίες
(π.χ. Reduced Instruction Set Computer (RISC), Relational Database).
Μια απαίτηση που απαγορεύει τη χρήση δεικτών (pointers) θα μπορούσε να
είναι ένα άλλο παράδειγμα.

### *Περιορισμοί ποιότητας υπηρεσιών*

Αυτές οι απαιτήσεις δεν περιορίζουν τη χρήση συγκεκριμένων τεχνολογιών
με συγκεκριμένα ονόματα. Αντίθετα, καθορίζουν αποδεκτά επίπεδα απόδοσης
που πρέπει να έχει μια αυτοματοποιημένη λύση.
Παραδείγματα αυτών είναι ο χρόνος απόκρισης, ο ρυθμός επεξεργασίας,
η ακρίβεια, η αξιοπιστία και η επεκτασιμότητα.
Πρότυπο ISO/IEC 25010: "Μηχανική συστημάτων και λογισμικού - Απαιτήσεις
ποιότητας και αξιολόγηση συστημάτων και λογισμικού (SQuaRE) - Μοντέλα ποιότητας
συστημάτων και λογισμικού" περιλαμβάνει μια μεγάλη λίστα των ειδών
των ποιοτικών χαρακτηριστικών υπηρεσίας που μπορεί να είναι σχετικά με
το λογισμικό. Η ασφάλεια είναι επίσης ένα ιδιαίτερα σημαντικό θέμα όπου οι
απαιτήσεις τείνουν να παραβλέπονται. (Για λεπτομέρειες σχετικά με τα είδη
των συγκεκριμένων απαιτήσεων ασφαλείας που πρέπει να ληφθούν υπόψη,
δείτε τo γνωστικό πεδίο ασφαλείας.)

### *Γιατί κατηγοριοποιούμε τις απαιτήσεις με αυτόν τον τρόπο;*

Η κατηγοριοποίηση των απαιτήσεων με αυτόν τον τρόπο είναι
χρήσιμη για τους εξής λόγους:

* Οι απαιτήσεις σε μία κατηγορία τείνουν να προέρχονται
από διαφορετικές πηγές παρά από άλλες κατηγορίες.
* Οι τεχνικές απόκτησης συχνά διαφέρουν ανάλογα με την πηγή.
* Οι τεχνικές ανάλυσης διαφέρουν ανάλογα με την κατηγορία.
* Οι τεχνικές προδιαγραφής διαφέρουν ανάλογα με την κατηγορία.
* Οι αρμόδιοι επαλήθευσης διαφέρουν ανάλογα με την κατηγορία.
* Οι διαφορετικές κατηγορίες επηρεάζουν το αποτέλεσμα του λογισμικού
με διαφορετικούς τρόπους.

Επιπλέον, η οργάνωση των απαιτήσεων σε αυτές τις κατηγορίες
είναι επωφελής με τους ακόλουθους τρόπους:

* Η πολυπλοκότητα μπορεί να διαχειρίζεται καλύτερα επειδή διαφορετικές
περιοχές μπορούν να αντιμετωπίζονται ξεχωριστά. Δηλαδή, Οι μηχανικοί
λογισμικού μπορούν να αντιμετωπίζουν τις πολιτικές και τις διαδικαστικές
πολυπλοκότητες χωρίς να ανησυχούν ταυτόχρονα για τα ζητήματα της
τεχνολογίας αυτοματοποίησης (και αντίστροφα).
Ένα μεγάλο πρόβλημα χωρίζεται σε δύο μικρότερα.
Αυτή είναι η κλασική διαχείριση της πολυπλοκότητας με τη
μέθοδο διαίρει και βασίλευε.

* Διακριτές περιοχές ειδίκευσης μπορούν να απομονωθούν· οι ενδιαφερόμενοι
φορείς, και όχι οι μηχανικοί λογισμικού, είναι οι ειδικοί στις πολιτικές
και διαδικασίες που πρέπει να αυτοματοποιηθούν. Οι μηχανικοί λογισμικού,
και όχι οι ενδιαφερόμενοι φορείς, είναι οι ειδικοί της τεχνολογίας.
Όταν δίνονται σε έναν επαγγελματία της επιχείρησης συνεχόμενες λειτουργικές
και μη λειτουργικές απαιτήσεις για επισκόπηση ή επαλήθευση, μπορεί "να τα
παρατήσει" επειδή δεν κατανοεί - ή ακόμη και δεν ενδιαφέρεται για -
τα ζητήματα της τεχνολογίας. Ενώ, ο ειδικός στις απαιτήσεις επιθεωρητής μπορεί
να επικεντρωθεί μόνο στο υποσύνολο των απαιτήσεων που τον αφορούν.

Το Τέλειο Φίλτρο Τεχνολογίας (Perfect Technology Filter) που περιγράφεται,
βοηθά να διαχωριστούν οι λειτουργικές από τις μη λειτουργικές απαιτήσεις. Με
απλά λόγια, οι λειτουργικές απαιτήσεις είναι αυτές που θα χρειαζόταν να
δηλωθούν ακόμα και αν υπήρχε ένας υπολογιστής με άπειρη ταχύτητα, απεριόριστη
μνήμη, μηδενικό κόστος, χωρίς αποτυχίες, κλπ., πάνω στον οποίο θα μπορούσε να
κατασκευαστεί το λογισμικό. Όλες οι άλλες απαιτήσεις του προϊόντος λογισμικού
είναι περιορισμοί στις τεχνολογίες αυτοματοποίησης και επομένως είναι μη λειτουργικές.

Τα μεγάλα συστήματα συχνά καλύπτουν περισσότερους από έναν τομέα
θεμάτων ή πεδίων. Η αναδρομική σχεδίαση δείχνει
πώς οι μη λειτουργικές απαιτήσεις σε έναν γονικό τομέα μπορούν να γίνουν,
ή να προκαλέσουν, λειτουργικές απαιτήσεις σε έναν τομέα "παιδί".
Για παράδειγμα, μια μη λειτουργική απαίτηση σχετικά με την ασφάλεια του
χρήστη σε έναν γονικό τομέα τραπεζικών εργασιών μπορεί να γίνει, ή να
προκαλέσει λειτουργικές απαιτήσεις σε έναν "παιδικό" τομέα ασφαλείας.
Αντίστοιχα, οι διασταυρούμενες μη λειτουργικές απαιτήσεις σχετικά με τον
έλεγχο και τη διαχείριση συναλλαγών σε έναν γονικό τομέα τραπεζικών εργασιών
μπορούν να γίνουν, ή να προκαλέσουν λειτουργικές απαιτήσεις σε έναν "παιδικό"
τομέα ελέγχου και σε έναν "παιδικό" τομέα συναλλαγών. Η ανάλυση μεγάλων
συστημάτων σε ένα σύνολο σχετικών τομέων μειώνει σημαντικά την πολυπλοκότητα.

### *Απαιτήσεις συστήματος και λογισμικού*

Το Διεθνές συμβούλιο για την τεχνολογία λογισμικού και συστημάτων (INCOSE)
ορίζει ένα «σύστημα» "ως έναν αλληλεπιδραστικό συνδυασμό στοιχείων για την
επίτευξη ενός καθορισμένου στόχου. Αυτά τα στοιχεία περιλαμβάνουν το υλικό
του υπολογιστή (hardware), το λογισμικό (software), το υλικο-λογισμικό
(firmware), τους ανθρώπους, τις πληροφορίες, τις τεχνικές, τις εγκαταστάσεις,
τις υπηρεσίες, καθώς και άλλα στοιχεία υποστήριξης".

Σε ορισμένες περιπτώσεις, είναι χρήσιμο ή απαραίτητο να διαχωρίζονται οι
απαιτήσεις συστήματος από τις απαιτήσεις λογισμικού. Οι απαιτήσεις συστήματος
ισχύουν για μεγαλύτερα συστήματα - για παράδειγμα, ένα αυτόνομο όχημα.
Οι απαιτήσεις λογισμικού ισχύουν μόνο για ένα στοιχείο λογισμικού σε αυτό
το μεγαλύτερο σύστημα. Ορισμένες απαιτήσεις λογισμικού μπορεί να προέρχονται
από απαιτήσεις συστήματος. Σε άλλες περιπτώσεις,
το λογισμικό αποτελεί αυτό καθαυτό το σύστημα ενδιαφέροντος, και το υλικό
και το σύστημα υποστήριξης θεωρούνται ως πλατφόρμα ή υποδομή, ώστε οι
απαιτήσεις συστήματος να είναι κυρίως απαιτήσεις λογισμικού.

### *Παραγόμενες απαιτήσεις*

Στην πράξη, οι απαιτήσεις μπορούν να είναι ευαίσθητες στο πλαίσιο και να
εξαρτώνται από την οπτική γωνία. Ένα εξωτερικό ενδιαφερόμενο μέρος μπορεί να
επιβάλει μια απαίτηση εύρους και αυτό θα ήταν μια απαίτηση για ολόκληρο το
έργο - ακόμη κι αν αυτό το έργο περιλαμβάνει εκατοντάδες μηχανικούς λογισμικού.
Η απόφαση ενός αρχιτέκτονα να χρησιμοποιήσει ένα στυλ αρχιτεκτονικής αγωγών
και φίλτρων δεν θα ήταν μια απαίτηση από την οπτική γωνία των ενδιαφερομένων
στο συνολικό έργο, αλλά μια απόφαση σχεδιασμού. Αλλά η ίδια αυτή απόφαση,
όταν αντιμετωπίζεται από την οπτική γωνία μιας υποομάδας που είναι υπεύθυνη
για την κατασκευή ενός συγκεκριμένου φίλτρου, θα θεωρείται απαίτηση.

Η αεροδιαστημική βιομηχανία χρησιμοποιεί εδώ και καιρό τον όρο παραγόμενη
απαίτηση για να σημαίνει μια απαίτηση που δεν δόθηκε από εξωτερικό
ενδιαφερόμενο στο σύνολο του έργου, αλλά επιβλήθηκε μέσα στη μεγαλύτερη
ομάδα ανάπτυξης. Η αρχιτεκτονική απόφαση των αγωγών και φίλτρων του
αρχιτέκτονα ταιριάζει σε αυτόν τον ορισμό. Αυτή η επιλογή θα θεωρείτο
μια απόφαση σχεδιασμού από την άποψη των εξωτερικών ενδιαφερομένων,αλλά ως
απαίτηση για τις υποομάδες που είναι υπεύθυνες για την ανάπτυξη κάθε φίλτρου.


### *Δραστηριότητες απαιτήσεων λογισμικού*

![Σχήμα 1.3 Δραστηριότητες απαιτήσεων λογισμικού.](images/.png)

Στο σχήμα 1.3 παρουσιάζονται οι δραστηριότητες ανάπτυξης και
διαχείρισης απαιτήσεων.

Η ανάπτυξη απαιτήσεων, συνολικά, μπορεί να θεωρηθεί ως "επίτευξη συμφωνίας
για το τι λογισμικό πρέπει να κατασκευαστεί". Αντίθετα, η διαχείριση
απαιτήσεων μπορεί να θεωρηθεί ως "διατήρηση αυτής της συμφωνίας στον χρόνο".
Κάθε δραστηριότητα παρουσιάζεται σε αυτό το γνωστικό πεδίο. Οι δραστηριότητες
ανάπτυξης απαιτήσεων παρουσιάζονται ως ξεχωριστά θέματα, με τη διαχείριση
απαιτήσεων να παρουσιάζεται ως ένα μόνο θέμα.

## **Εκμαίευση απαιτήσεων**

Ο στόχος της εκμαίευσης απαιτήσεων είναι να εντοπιστούν οι υποψήφιες απαιτήσεις.
Αυτή η διαδικασία ονομάζεται επίσης «σύλληψη απαιτήσεων», «ανακάλυψη
απαιτήσεων» ή «απόκτηση απαιτήσεων». Όπως αναφέρθηκε προηγουμένως, ένα πρόβλημα
στην εργασία με απαιτήσεις σε πραγματικά έργα λογισμικού είναι η έλλειψη
ολοκλήρωσης. Αυτό μπορεί να οφείλεται σε ανεπαρκή εκμαίευση. Παρόλο που δεν
υπάρχει εγγύηση για μια πλήρη συλλογή απαιτήσεων, μια καλά εκτελεσμένη σύλληψη
βοηθά στο να μειωθεί η έλλειψη ολοκλήρωσης.

### *Πηγές απαιτήσεων*

Οι απαιτήσεις προέρχονται - μπορούν να εκμαιευτούν - από πολλές
διαφορετικές πηγές. Όλες οι δυνητικές πηγές απαιτήσεων πρέπει να αναγνωριστούν
και να αξιολογηθούν. Ένας ενδιαφερόμενος μπορεί να οριστεί ως οποιοσδήποτε
άνθρωπος, ομάδα ή οργανισμός που:

* εμπλέκεται ενεργά στο έργο,
* επηρεάζεται από το αποτέλεσμα του έργου,
* μπορεί να επηρεάσει το αποτέλεσμα του έργου.

Οι τυπικοί ενδιαφερόμενοι για τα έργα λογισμικού περιλαμβάνουν, αλλά δεν
περιορίζονται μόνο στα ακόλουθα:

* πελάτες - τόσο εκείνοι που πληρώνουν για το λογισμικό που θα κατασκευαστεί
(π.χ. διοίκηση οργανισμού) (clients), όσο και εκείνοι που αποφασίζουν εάν
ένα προϊόν λογισμικού θα τεθεί σε λειτουργία (customers),
* χρήστες - εκείνοι που αλληλεπιδρούν άμεσα ή έμμεσα με το λογισμικό
οι χρήστες μπορούν συχνά να χωριστούν σε διακριτές κατηγορίες χρηστών που
διαφέρουν στη συχνότητα χρήσης, τις εργασίες που εκτελούν, το επίπεδο
εξειδίκευσης και γνώσης, το επίπεδο προνομίων κ.λπ.,
* ειδικοί πάνω στο θέμα (SMEs),
* προσωπικό λειτουργίας,
* προσωπικό πρώτου επιπέδου υποστήριξης προϊόντος,
* σχετικά επαγγελματικά σώματα,
* κανονιστικές αρχές,
* ομάδες ειδικού ενδιαφέροντος,
* άνθρωποι που μπορεί να επηρεαστούν αρνητικά εάν το έργο είναι επιτυχημένο,
* προγραμματιστές.

Οι κατηγορίες των ενδιαφερομένων είναι ομάδες ενδιαφερομένων που έχουν
παρόμοιες απόψεις και ανάγκες. Η εργασία σε ένα έργο λογισμικού με
κατηγορίες ενδιαφερομένων αντί για ατομικούς ενδιαφερομένους μπορεί
να παράγει σημαντική, πρόσθετη κατανόηση.

Πολλά έργα ωφελούνται από τη διενέργεια μιας ανάλυσης ενδιαφερομένων μερών για
την αναγνώριση όσο το δυνατόν περισσότερων ενδιαφερομένων μερών. Αυτό μειώνει
την πιθανότητα να υπάρχει μεροληψία στις απαιτήσεις υπέρ των ενδιαφερομένων
μερών που εκπροσωπούνται καλύτερα και κατά των λιγότερο καλά
εκπροσωπούμενων ενδιαφερομένων μερών. Η ανάλυση αυτή μπορεί επίσης
να καθοδηγεί τη διαπραγμάτευση και την επίλυση συγκρούσεων όταν οι απαιτήσεις
από μια κατηγορία ενδιαφερομένων συγκρούονται με απαιτήσεις από άλλη.

Οι απαιτήσεις δεν προέρχονται απαραίτητα μόνο από ανθρώπους.
Άλλες πηγές απαιτήσεων μπορούν να είναι:
* Η τεκμηρίωση, όπως οι απαιτήσεις για προηγούμενες εκδόσεις, οι διακηρύξεις
αποστολής, το συνολικό σχέδιο λειτουργίας,
* Άλλα συστήματα,
* το ευρύτερο επιχειρησιακό περιβάλλον συμπεριλαμβανομένων των πολιτικών και
των διαδικασιών του οργανισμού,
* Το περιβάλλον υπολογιστικών συστημάτων.

### *Συνήθεις τεχνικές εκμαίευσης απαιτήσεων*

Μπορούν να χρησιμοποιηθούν πολλές τεχνικές για την εκμαίευση απαιτήσεων από
τα ενδιαφερόμενα μέρη. Ορισμένες τεχνικές λειτουργούν καλύτερα με συγκεκριμένες
κατηγορίες ενδιαφερομένων μερών. Οι συνηθισμένες τεχνικές ανάκτησης απαιτήσεων
από ενδιαφερόμενα μέρη περιλαμβάνουν τα ακόλουθα:

* συνεντεύξεις,
* συναντήσεις, πιθανότατα που συμπεριλαμβάνουν brainstorming,
* Από κοινού Ανάπτυξη Εφαρμογών (JAD), Από κοινού Σχεδιασμός Απαιτήσεων (JRP)
και άλλα οργανωμένα εργαστήρια,
* ανάλυση πρωτοκόλλου,
* ομάδες εστίασης,
* ερωτηματολόγια και έρευνες αγοράς,
* διερευνητικά πρωτότυπα, συμπεριλαμβανομένων των πρωτοτύπων διεπαφών χρήστη
χαμηλής και υψηλής πιστότητας,
* καταγραφή ιστοριών χρήστη.

Η εκμαίευση μπορεί να είναι δύσκολη και ο μηχανικός λογισμικού πρέπει να
γνωρίζει ότι (για παράδειγμα) οι χρήστες μπορεί να δυσκολεύονται να περιγράψουν
τις εργασίες τους, να αφήνουν αναπάντητες σημαντικές πληροφορίες ή να μην
είναι πρόθυμοι ή σε θέση να συνεργαστούν. Η εκμαίευση δεν είναι μια παθητική
δραστηριότητα. Ακόμα κι αν υπάρχουν συνεργάσιμοι και εύληπτοι ενδιαφερόμενοι,
ο μηχανικός λογισμικού πρέπει να εργαστεί σκληρά για να εκμαιεύσει τις σωστές
πληροφορίες. Πολλές απαιτήσεις προϊόντος είναι σιωπηρές ή μπορούν να βρεθούν
μόνο σε πληροφορίες που δεν έχουν συλλεχθεί ακόμα.

Οι απαιτήσεις μπορούν επίσης να αντληθούν από διάφορες πηγές πέρα από τα
ενδιαφερόμενα μέρη. Τέτοιες πηγές και τεχνικές περιλαμβάνουν τα εξής:

* προηγούμενες εκδόσεις του συστήματος,
* βάση δεδομένων παρακολούθησης ατελειών για προηγούμενες εκδόσεις του
συστήματος,
* συστήματα που επικοινωνούν με το σύστημα που βρίσκεται υπό ανάπτυξη,
* ανταγωνιστικό benchmarking,
* βιβλιογραφική έρευνα,
* Ο Οίκος Ποιότητας (House of Quality) της Εξάπλωσης της Λειτουργίας
Ποιότητας (QFD),
* παρατήρηση, όπου ο μηχανικός λογισμικού μελετά την εργασία και το
περιβάλλον μέσα στο οποίο αυτή πραγματοποιείται,
* μαθητεία, όπου ο μηχανικός λογισμικού μαθαίνει κάνοντας τη δουλειά,
* περιγραφές σεναρίων χρήσης,
* αποσύνθεση (π.χ. ικανότητες σε epics σε δυνατότητες σε stories),
* ανάλυση εργασιών,
* σχεδιαστική σκέψη (συναίσθηση, καθορισμός, συλλογισμός, πρωτότυπα, δοκιμές),
* Πρότυπο ISO/IEC 25010: "Μηχανική συστημάτων και λογισμικού - Απαιτήσεις
ποιότητας και αξιολόγηση συστημάτων και λογισμικού (SQuaRE) - Ποιοτικά μοντέλα
συστημάτων και λογισμικού",
* απαιτήσεις ασφαλείας, όπως συζητούνται στο γνωστικό πεδίο της Ασφάλειας,
* ισχύοντα πρότυπα και κανονισμοί.

## **Ανάλυση απαιτήσεων** {#req-analysis}

Οι απαιτήσεις σπάνια εξάγονται στην τελική τους μορφή. Συνήθως απαιτείται
περαιτέρω έρευνα για να αποκαλυφθούν οι πλήρεις και πραγματικές απαιτήσεις
που παρουσιάζονται από τις πληροφορίες που έχουν αρχικά συλλεχθεί. Η ανάλυση
απαιτήσεων βοηθά τους προγραμματιστές λογισμικού να κατανοήσουν τη σημασία και
τις συνέπειες των προτεινόμενων απαιτήσεων, τόσο ατομικά όσο και στο πλαίσιο
του ευρύτερου συνόλου απαιτήσεων.

### *Βασική ανάλυση απαιτήσεων*

Η παρακάτω λίστα επιθυμητών ιδιοτήτων των απαιτήσεων μπορεί να καθοδηγήσει τη
βασική ανάλυση απαιτήσεων. Ο μηχανικός λογισμικού προσπαθεί να καθιερώσει
οποιαδήποτε από αυτές τις ιδιότητες, σε περίπτωση που δεν εφαρμόζονται ακόμα.
Κάθε απαίτηση θα πρέπει:

* να είναι ξεκάθαρη (ερμηνεύσιμη με μόνο έναν τρόπο)
* να είναι ελέγξιμη (να μπορεί να ποσοτικοποιηθεί), που σημαίνει ότι η
συμμόρφωση ή η μη συμμόρφωση μπορεί να αποδειχθεί με σαφήνεια.
* να είναι δεσμευτική, που σημαίνει ότι οι πελάτες είναι διατεθειμένοι να
πληρώσουν για αυτήν και απρόθυμοι να μην την έχουν
* να αντιπροσωπεύει πραγματικές ανάγκες των ενδιαφερομένων μερών
* να χρησιμοποιεί το λεξιλόγιο των ενδιαφερομένων μερών
* να είναι αποδεκτή από όλα τα ενδιαφερόμενα μέρη

Η συλλογή των απαιτήσεων συνολικά θα πρέπει να είναι:

* ολοκληρωμένη, δηλαδή να ανταποκρίνεται επαρκώς στις συνθήκες των ορίων και
των εξαιρέσεων και τις ανάγκες ασφάλειας
* εσωτερικά συνεπής, δηλαδή καμία απαίτηση δεν συγκρούεται με κάποια άλλη
* εξωτερικά συνεπής, δηλαδή καμία απαίτηση δεν συγκρούεται με οποιοδήποτε
πηγαίο υλικό
* εφικτή, δηλαδή μπορεί να δημιουργηθεί μια λειτουργική, οικονομικά αποδοτική
λύση εντός των περιορισμών του κόστους, του χρονοδιαγράμματος, του προσωπικού
και άλλων περιορισμών

Σε ορισμένες περιπτώσεις, μια απαίτηση που έχει εκμαιευτεί αντιπροσωπεύει μια
λύση προς υλοποίηση αντί για το πραγματικό πρόβλημα που πρέπει να επιλυθεί.
Αυτό κινδυνεύει να οδηγήσει στην υλοποίηση μιας μη βέλτιστης λύσης.
Η τεχνική των "5 γιατί" (5-whys) περιλαμβάνει το επαναλαμβανόμενο ερώτημα
"Γιατί είναι αυτή η απαίτηση;" για να συγκλίνει στο πραγματικό πρόβλημα.
Η επανάληψη σταματά όταν η απάντηση είναι "Εάν αυτό δεν γίνει, τότε το πρόβλημα
του ενδιαφερόμενου μέρους δεν έχει λυθεί." Συχνά, το πραγματικό πρόβλημα
επιλύεται μετά από δύο ή τρεις κύκλους, αλλά η τεχνική ονομάζεται "5 γιατί" για
να ενθαρρύνει τους μηχανικούς να την επαναλαμβάνουν όσο το δυνατόν περισσότερο.

### *Οικονομικά των περιορισμών της ποιότητας υπηρεσιών*

Οι περιορισμοί της ποιότητας υπηρεσιών μπορούν να είναι ιδιαίτερα
προκλητικοί. Αυτό συμβαίνει γενικά επειδή οι μηχανικοί δεν τους λαμβάνουν
υπόψη από οικονομική σκοπιά. Η εικόνα 1.4 απεικονίζει την οικονομική
προοπτική ενός τυπικού περιορισμού ποιότητας υπηρεσιών, όπως η χωρητικότητα,
η επεξεργαστική ικανότητα και η αξιοπιστία, όπου η αξία αυξάνεται με το
επίπεδο απόδοσης. Αυτή η καμπύλη αντανακλάται κατακόρυφα για περιορισμούς
ποιότητας υπηρεσιών, των οποίων η αξία μειώνεται καθώς το επίπεδο απόδοσης
αυξάνεται (παραδείγματα θα μπορούσαν να είναι ο χρόνος απόκρισης και ο μέσος
χρόνος επισκευής).

![Σχήμα 1.4 Η αξία ως συνάρτηση του επιπέδου επίδοσης.](images/.png)

Στο σχετικό εύρος επιπέδων απόδοσης, τα ενδιαφερόμενα μέρη έχουν μια αντίστοιχη
αξία εάν το σύστημα αποδίδει σε αυτό το επίπεδο. Η καμπύλη αξίας έχει δύο
σημαντικά σημεία:

1. Σημείο τέλειας απόδοσης - Αυτό είναι το πλέον ευνοϊκό επίπεδο απόδοσης,
   πέρα από το οποίο δεν υπάρχει επιπλέον όφελος. Ακόμα και αν το σύστημα μπορεί
   να λειτουργήσει καλύτερα από το σημείο τέλειας απόδοσης, ο πελάτης δεν μπορεί
   να αξιοποιήσει αυτήν την δυναμικότητα. Για παράδειγμα, ένα κοινωνικό δίκτυο
   που υποστηρίζει περισσότερα μέλη από τον παγκόσμιο πληθυσμό θα είχε αυτήν
   την υπερβολική δυναμικότητα.
2. Σημείο αποτυχίας - Αυτό είναι το πλέον ανεπιθύμητο επίπεδο απόδοσης, πέρα
   από το οποίο δεν υπάρχει περαιτέρω μείωση στο όφελος. Για παράδειγμα, το
   κοινωνικό δίκτυο μπορεί να χρειάζεται να υποστηρίξει τουλάχιστον ένα ελάχιστο
   μερίδιο στην αγορά για να είναι επικερδές ως πλατφόρμα.

Ένα ποσοτικοποιημένο σημείο απαίτησης, ακόμη κι αν αναφέρεται ρητά, συνήθως
είναι αυθαίρετο. Συχνά βασίζεται σε αυτό που αισθάνεται να ζητήσει
δικαιολογημένα ένας πελάτης, λαμβάνοντας υπόψη την αξία που καταβάλλει για το
λογισμικό. Ακόμα και αν οι μηχανικοί λογισμικού δεν μπορούν να κατασκευάσουν
ένα σύστημα που να ικανοποιεί πλήρως το αναφερόμενο σημείο απαίτησης, το
λογισμικό συνήθως εξακολουθεί να έχει αξία. Απλά έχει λιγότερη αξία από αυτήν
που περίμενε ο πελάτης. Επιπλέον, η ικανότητα υπέρβασης του σημείου απαίτησης
μπορεί να αυξήσει σημαντικά την αξία σε ορισμένες περιπτώσεις.

Το κόστος για να επιτευχθεί ένα συγκεκριμένο επίπεδο επίδοσης είναι συνήθως μια
βαθμιδωτή συνάρτηση. Αρχικά, για ένα συγκεκριμένο επίπεδο επένδυσης,
υπάρχει ένα μέγιστο εφικτό επίπεδο επίδοσης. Στη συνέχεια, απαιτείται
επιπλέον επένδυση, και αυτή η επιπλέον επένδυση επιτρέπει την επίδοση έως ένα
νέο, πιο επιθυμητό μέγιστο. Η Εικόνα 1.5 απεικονίζει το επίπεδο επίδοσης με τον
πλέον οικονομικό τρόπο - το επίπεδο επίδοσης με τη μέγιστη θετική διαφορά
μεταξύ της αξίας σε αυτό το επίπεδο επίδοσης και του κόστους για την
επίτευξή του.

![Σχήμα 1.5 Το πιο οικονομικά αποδοτικό επίπεδο επίδοσης.](images/.png)

(βλ. γνωστικό πεδίο των οικονομικών τεχνολογίας λογισμικού για περισσότερες
πληροφορίες σχετικά με τη διεξαγωγή οικονομικών αναλύσεων όπως αυτή.)

Ο μηχανικός λογισμικού θα πρέπει να δώσει ιδιαίτερη προσοχή στις θετικές και
αρνητικές σχέσεις μεταξύ των περιορισμών ποιότητας υπηρεσίας
(π.χ. εικόνα 14-2). Ορισμένοι περιορισμοί ποιότητας υπηρεσίας
αλληλοϋποστηρίζονται, δηλαδή η βελτίωση του επιπέδου επίδοσης του ενός θα
βελτιώσει αυτόματα το επίπεδο επίδοσης του άλλου. Για παράδειγμα, όσο πιο
τροποποιήσιμος είναι ο κώδικας, τόσο πιο αξιόπιστος είναι, καθώς η
τροποποιησιμότητα και η αξιοπιστία είναι, σε έναν βαθμό, αποτέλεσμα του πόσο
καθαρός είναι ο κώδικας. Από την άλλη πλευρά, όσο υψηλότερη είναι η ταχύτητα
του κώδικα, τόσο λιγότερο τροποποιήσιμος μπορεί να είναι, επειδή η υψηλή
ταχύτητα συχνά επιτυγχάνεται μέσω βελτιστοποιήσεων που καθιστούν τον κώδικα
πιο περίπλοκο.

### *Τυπική ανάλυση* {#formal-analysis}

Η τυπική ανάλυση παρουσιάζει οφέλη σε ορισμένους τομείς εφαρμογής,
ειδικά σε συστήματα υψηλής ακεραιότητας. Η επίσημη έκφραση των
απαιτήσεων εξαρτάται από τη χρήση μιας γλώσσας προδιαγραφής με επίσημα
καθορισμένους συμβολισμούς. Η τυπική ανάλυση έχει δύο οφέλη. Πρώτον, οι
τυπικές απαιτήσεις είναι ακριβείς και συνοπτικές, που (στη θεωρία)
θα μειώσει τη πιθανότητα παρερμηνείας. Δεύτερον, οι απαιτήσεις μπορούν να
αιτιολογηθούν, επιτρέποντας να αποδειχθούν επιθυμητές ιδιότητες του
καθορισμένου λογισμικού. Αυτό επιτρέπει τη στατική επικύρωση πως το λογισμικό,
που διαμορφώνεται από τις απαιτήσεις, έχει πράγματι τις ιδιότητες που ο
πελάτης, οι χρήστες, και ο μηχανικός λογισμικού προσδοκούν να έχει
(για παράδειγμα, την απουσία αδιεξόδου).

Το θέμα αυτό σχετίζεται επίσης με τις Τυπικές μεθόδους
στο γνωστικό πεδίο Μοντέλα και μέθοδοι τεχνολογίας λογισμικού.

### *Αντιμετώπιση συγκρούσεων στις απαιτήσεις*

Όταν ένα έργο έχει περισσότερα - και πιο διαφορετικά - ενδιαφερόμενα μέρη,
είναι πιο πιθανό να υπάρχουν συγκρούσεις μεταξύ των απαιτήσεων. Ένα ιδιαίτερα
σημαντικό κομμάτι της ανάλυσης απαιτήσεων είναι η αναγνώριση και διαχείριση
τέτοιων συγκρούσεων. Αφού αναγνωριστούν οι αντιφατικές απαιτήσεις,
ο μηχανικός μπορεί να εξετάσει δύο διαφορετικές προσεγγίσεις για
τη διαχείριση της σύγκρουσης (και πιθανώς και άλλες προσεγγίσεις) και να
καθορίσει τον καταλληλότερο τρόπο δράσης.

Μία προσέγγιση είναι να διαπραγματευτεί μια επίλυση μεταξύ των ενδιαφερόμενων
μερών που έρχονται σε αντιπαράθεση. Στις περισσότερες περιπτώσεις, δεν είναι
σοφό για τον μηχανικό λογισμικού να παίρνει μια μονομερή απόφαση, έτσι ώστε
να καθίσταται αναγκαία η διαβούλευση με τα ενδιαφερόμενα μέρη για
να επιτευχθεί συναίνεση για ένα κατάλληλο αντιστάθμισμα. Συνήθως είναι
πολύ σημαντικό, για συμβατικούς λόγους, τέτοιου είδους αποφάσεις να
είναι ανιχνεύσιμες από τον πελάτη. Ένα συγκεκριμένο παράδειγμα είναι
η *διαχείριση του εύρους του έργου* - δηλαδή, την εύρεση ισορροπίας μεταξύ
αυτού που επιθυμείται στις αναφερόμενες απαιτήσεις του προϊόντος λογισμικού
και αυτού που μπορεί να επιτευχθεί δεδομένων των απαιτήσεων του έργου για
κόστος, προγραμματισμό, προσωπικό και άλλους περιορισμούς σε επίπεδο έργου.
Υπάρχουν πολλές χρήσιμες πηγές για πληροφορίες σχετικά με τις διαπραγματεύσεις
και την επίλυση συγκρούσεων.

Μια άλλη προσέγγιση είναι η εφαρμογή της *ανάπτυξης οικογένειας προϊόντων* (π.χ.
[20]). Η οποία περιλαμβάνει τη διαίρεση των απαιτήσεων σε δύο κατηγορίες. Η
πρώτη κατηγορία περιλαμβάνει τις *σταθερές απαιτήσεις* (invariants). Αυτές είναι
απαιτήσεις στις οποίες συμφωνούν όλα τα ενδιαφερόμενα μέρη. Η δεύτερη κατηγορία
περιλαμβάνει τις *μεταβλητές απαιτήσεις* (variants), όπου υπάρχει σύγκρουση.
Ο μηχανικός λογισμικού μπορεί να επικεντρωθεί στην κατανόηση του εύρους των
παραλλαγών που απαιτούνται για να ικανοποιηθούν όλα τα ενδιαφερόμενα μέρη.
Το λογισμικό μπορεί να σχεδιαστεί χρησιμοποιώντας την
*σχεδίαση με βάση αμετάβλητες συνθήκες* (design to invariants), ώστε να
ενσωματωθούν οι σταθερές απαιτήσεις και τον *σχεδιασμό για αλλαγή* για να
συμπεριλάβει σημεία προσαρμογής για τη διαμόρφωση μιας εκδοχής του
συστήματος που ταιριάζει καλύτερα στα σχετικά ενδιαφερόμενα μέρη. Ένα απλό
παράδειγμα, ορισμένοι χρήστες μιας εφαρμογής καιρού απαιτούν να εμφανίζονται οι
θερμοκρασίες σε βαθμούς Κελσίου, ενώ άλλοι απαιτούν βαθμούς Φαρενάιτ.

## **Προσδιορισμός απαιτήσεων** {#req-specif}

Ο *προσδιορισμός απαιτήσεων* αφορά την καταγραφή των απαιτήσεων, ώστε να μπορούν
να αποθηκευτούν και να μεταδοθούν. Ο προσδιορισμός απαιτήσεων μπορεί να είναι
το πιο συζητημένο θέμα σε αυτή το γνωστικό πεδίο. Ο διάλογος επικεντρώνεται
σε ερωτήσεις, όπως:

* πρέπει να καταγραφούν οι απαιτήσεις;
* εάν καταγραφούν οι απαιτήσεις, ποια μορφή πρέπει να έχουν;
* εάν καταγραφούν οι απαιτήσεις, πρέπει να διατηρούνται διαχρονικά;

Δεν υπάρχουν συγκεκριμένες απαντήσεις σε αυτές τις ερωτήσεις. Η απάντηση σε
κάθε μία μπορεί να εξαρτάται από παράγοντες, όπως:

* η εξοικείωση του μηχανικού λογισμικού με τον επιχειρηματικό κλάδο,
* το προηγούμενο για αυτόν τον τύπο λογισμικού,
* o βαθμός κινδύνου (π.χ. πιθανότητα, σοβαρότητα) λάθος απαιτήσεων,
* την αναμενόμενη κινητικότητα προσωπικού κατά τη διάρκεια της υπηρεσιακής
ζωής του λογισμικού,
* η γεωγραφική κατανομή των μελών της ομάδας ανάπτυξης,
* η συμμετοχή των ενδιαφερόμενων μερών κατά τη διάρκεια του έργου,
* εάν αναμένεται η χρήση τυποποιημένου λογισμικού ή βιβλιοθήκης ανοικτού κώδικα,
* εάν πρόκειται να γίνει εξωτερική ανάθεση κάποιου σχεδιασμού ή κατασκευής,
* ο αναμενόμενος βαθμός ελέγχου βασισμένου σε απαιτήσεις,
* η προσπάθεια που απαιτείται για τη χρήση μιας τεχνικής προσδιορισμού υποψήφιου,
* η ακρίβεια που απαιτείται από τις εκτιμήσεις βασισμένες σε απαιτήσεις,
* ο βαθμός ιχνηλασιμότητας απαιτήσεων που απαιτείται, εάν απαιτείται,
* οι συμβατικές επιβαρύνσεις του περιεχομένου και της μορφής προδιαγραφών
απαιτήσεων.

Όπως αναφέρεται στην εισαγωγή του παρόντος γνωστικού πεδίου, τα *τι* και *πώς*
της δουλειάς των απαιτήσεων λογισμικού σε ένα έργο πρέπει να καθοριστούν από τη
φύση του κατασκευαζόμενου λογισμικού, όχι από τον κύκλο ζωής κάτω από τον οποίο
κατασκευάζεται. Οι μελλοντικοί συντηρητές δεν θα πρέπει να μπορούν να
αντιληφθούν τον κύκλο ζωής που χρησιμοποιήθηκε στην προηγούμενη ανάπτυξη μόνο
από τη μορφή αυτών των απαιτήσεων. Ο αντίκτυπος του επιλεγμένου κύκλου ζωής
πρέπει να περιορίζεται στην πληρότητα των απαιτήσεων σε οποιοδήποτε σημείο του
έργου. Σε έναν κύκλο ζωής καταρράκτη, αναμένεται να καθοριστούν πλήρως οι
απαιτήσεις στο τέλος της φάσης των απαιτήσεων. Σε έναν ευέλικτο κύκλο ζωής,
αναμένεται να αλλάζουν, να αυξάνονται ή να απορρίπτονται οι απαιτήσεις διαρκώς
και να μην είναι πλήρεις μέχρι το τέλος του έργου.

Ορισμένοι οργανισμοί έχουν μια κουλτούρα τεκμηρίωσης απαιτήσεων, ενώ άλλοι
όχι. Δυναμικά νεοφυή πρότζεκτ συχνά κινούνται από ένα ισχυρό προϊοντικό
όραμα και περιορισμένους πόρους. Οι ομάδες τους μπορεί να θεωρούν την
τεκμηρίωση απαιτήσεων ως περιττή επιβάρυνση. Ωστόσο, καθώς αυτά τα προϊόντα
εξελίσσονται και ωριμάζουν, οι μηχανικοί λογισμικού συχνά αναγνωρίζουν ότι
χρειάζεται να ανακτήσουν τις απαιτήσεις που ενέπνευσαν τα χαρακτηριστικά του
προϊόντος προκειμένου να αξιολογήσουν την επίδραση των προτεινόμενων αλλαγών.
Επομένως, η τεκμηρίωση των απαιτήσεων και η διαχείριση των αλλαγών γίνονται
σημαντικές για τη μακροπρόθεσμη επιτυχία. Η προσέγγιση ενός έργου ως προς τις
απαιτήσεις γενικά και την προδιαγραφή απαιτήσεων ειδικότερα, μπορεί να
εξελιχθεί κατά τη διάρκεια της διάρκειας ζωής του λογισμικού.

Η πιο βασική συμβουλή για την τεκμηρίωση των απαιτήσεων είναι να βασίζεται σε
μια *ανάλυση κοινού*. Ποιοι είναι οι διαφορετικοί καταναλωτές που θα
χρειαστούν πληροφορίες από μια προδιαγραφή απαιτήσεων; Ποιες πληροφορίες θα
χρειαστούν; Πώς μπορούν αυτές οι πληροφορίες να συσκευαστούν και να
παρουσιαστούν έτσι ώστε κάθε καταναλωτής να λαμβάνει τις πληροφορίες που
χρειάζεται με την ελάχιστη προσπάθεια;

Υπάρχει ένας βαθμός επικάλυψης και εξάρτησης μεταξύ ανάλυσης και προδιαγραφής
απαιτήσεων. Η χρήση συγκεκριμένων τεχνικών προδιαγραφής απαιτήσεων - ειδικότερα
τεχνικών προδιαγραφής απαιτήσεων βασισμένων σε μοντέλα - επιτρέπει και
ενθαρρύνει την ανάλυση απαιτήσεων που μπορεί να υπερβαίνει αυτό που έχει
ήδη παρουσιαστεί.

Οι καταγεγραμμένες απαιτήσεις λογισμικού πρέπει να υπόκεινται στις ίδιες
πρακτικές διαχείρισης σχηματισμών με τα άλλα παραδοτέα των διαδικασιών του
κύκλου ζωής του λογισμικού. (βλ. το γνωστικό πεδίο της διαχείρισης σχηματισμών
για μια λεπτομερή συζήτηση.) Επιπλέον, όταν είναι πρακτικό, οι μεμονωμένες
απαιτήσεις υπόκεινται επίσης σε διαχείριση σχηματισμών, η οποία υποστηρίζεται
γενικά από ένα εργαλείο διαχείρισης απαιτήσεων. (βλ. εργαλεία
απαιτήσεων λογισμικού.)

Υπάρχουν αρκετές γενικές κατηγορίες τεχνικών προδιαγραφής απαιτήσεων, κάθε μία
από τις οποίες συζητείται παρακάτω. Η προδιαγραφή απαιτήσεων για ένα
συγκεκριμένο έργο μπορεί επίσης να χρησιμοποιεί διάφορες τεχνικές.
Το πρότυπο ISO/IEC/IEEE 29148 [26] και πολλά άλλα, προσφέρουν πρότυπα για
την τεκμηρίωση απαιτήσεων.

### *Αδόμητος προσδιορισμός απαιτήσεων σε φυσική γλώσσα*

Ο *προσδιορισμός απαιτήσεων σε φυσική γλώσσα* εκφράζει απαιτήσεις σε
κοινή, συνηθισμένη γλώσσα. Ο προσδιορισμός απαιτήσεων σε φυσική γλώσσα
μπορεί να είναι δομημένος ή αδόμητος.

Ένας τυπικός αδόμητος προσδιορισμός απαιτήσεων σε φυσική γλώσσα
είναι μια συλλογή
δηλώσεων σε φυσική γλώσσα, όπως "Το σύστημα θα πρέπει να ...".
Για παράδειγμα, οι επιχειρησιακοί κανόνες είναι
δηλώσεις που καθορίζουν ή περιορίζουν κάποιο
κομμάτι της δομής ή της συμπεριφοράς της επιχείρησης προς αυτοματοποίηση.
"Ένας φοιτητής δεν μπορεί να εγγραφεί στα μαθήματα του επόμενου εξαμήνου αν
υπάρχουν οποιεσδήποτε οφειλές διδάκτρων" είναι ένα παράδειγμα ενός
επιχειρησιακού κανόνα που λειτουργεί ως απαίτηση για το λογισμικό
εγγραφής μαθημάτων ενός πανεπιστημίου. Κάποια
έργα μπορούν να δημοσιεύουν ένα εγχειρίδιο χρήσης ως ικανοποιητικό
προσδιορισμός απαιτήσεων, αν και υπάρχουν περιορισμοί στο πόσο αποτελεσματικό
αυτό μπορεί να είναι (Βλ. επίσης [26]).

### *Δομημένος προσδιορισμός απαιτήσεων σε φυσική γλώσσα*

Ο δομημένος προσδιορισμός απαιτήσεων σε φυσική γλώσσα επιβάλλει
περιορισμούς στον τρόπο που εκφράζονται οι απαιτήσεις.
Ο στόχος είναι να αυξηθεί η ακρίβεια και η συνοπτικότητα.

Το πιο απλό παράδειγμα μπορεί να είναι η μορφή ηθοποιός-ενέργεια.
Ο ηθοποιός είναι η οντότητα που είναι υπεύθυνη για την εκτέλεση της
ενέργειας και η ενέργεια είναι αυτό που πρέπει να συμβεί. Ένα γεγονός
εκκίνησης μπορεί να προηγηθεί του ηθοποιού, και η ενέργεια μπορεί να
ακολουθείται από μια προαιρετική συνθήκη ή προϋπόθεση. Η δήλωση "Όταν
αποστέλλεται μια παραγγελία, το σύστημα θα δημιουργεί ένα τιμολόγιο,
εκτός αν οι όροι της παραγγελίας είναι 'Προπληρωμένο'" χρησιμοποιεί
τη μορφή ηθοποιός-ενέργεια. Το γεγονός εκκίνησης είναι "Όταν αποστέλλεται
μια παραγγελία". Ο ηθοποιός είναι "το σύστημα". Η ενέργεια είναι
"θα δημιουργεί ένα τιμολόγιο". Η συνθήκη/προϋπόθεση είναι "εκτός
αν οι όροι της παραγγελίας είναι 'Προπληρωμένο'".

Ένα άλλο παράδειγμα είναι ένα πρότυπο προσδιορισμού περίπτωσης χρήσης,
όπως φαίνεται στο Σχήμα 1.6 (Βλ. [11] για κατευθυντήριες γραμμές για
την άρτια συγγραφή προσδιορισμού περιπτώσεων χρήσης).

![Σχήμα 1.6 Παράδειγμα δομημένου προσδιορισμού σε φυσική γλώσσα για μια περίπτωση χρήσης.](images/.png)

Η μορφή ιστορίας
χρήστη, "Ως <χρήστης> θέλω <δυνατότητα> ώστε <ωφέλεια>" καθώς και
οι πίνακες απόφασης είναι άλλα παραδείγματα.

### *Προσδιορισμός απαιτήσεων βασισμένος σε κριτήρια αποδοχής*

Αυτή η γενική προσέγγιση περιλαμβάνει δύο συγκεκριμένες παραλλαγές:
την ανάπτυξη οδηγούμενη από τον έλεγχο αποδοχής (Acceptance Test Driven
Development ή ATDD) και την ανάπτυξη οδηγούμενη από τη συμπεριφορά (Behavior
Driven Development ή BDD).

Η ανάπτυξη οδηγούμενη από τον έλεγχο αποδοχής
είναι μέρος της ευρύτερης προσέγγισης ανάπτυξης οδηγούμενης από τον
έλεγχο (TDD). (βλ. γνωστικό πεδίο Έλεγχος λογισμικού). Η κύρια ιδέα
της TDD είναι ότι οι περιπτώσεις ελέγχου προηγούνται της
κατασκευής. Επομένως, δεν γράφεται νέος κώδικας στην παραγωγή και
δεν τροποποιείται υπάρχων κώδικας εκτός αν τουλάχιστον μία
περίπτωση ελέγχου αποτύχει, είτε στο επίπεδο των δοκιμών μονάδων
είτε στο επίπεδο των δοκιμών αποδοχής. Η διαδικασία της
ανάπτυξης οδηγούμενη από τον έλεγχο αποδοχής έχει τρία βήματα:

1. Επιλέγεται μια λειτουργικότητα (π.χ. μια ιστορία χρήστη) για υλοποίηση.
2. Ένας ή περισσότεροι μηχανικοί λογισμικού, ένας ή περισσότεροι ειδικοί
   του επιχειρηματικού πεδίου και πιθανότατα ένας ή περισσότεροι επαγγελματίες
   διασφάλισης ποιότητας/ελέγχου συναντιούνται - πριν γίνει οποιοσδήποτε
   σχεδιασμός παραγωγής ή εργασία κατασκευής - για να συμφωνήσουν σε ένα
   σύνολο περιπτώσεων ελέγχου που πρέπει να εκτελεστούν για να
   δείξουν ότι η λειτουργικότητα έχει υλοποιηθεί σωστά.
3. Τουλάχιστον μια από αυτές τις περιπτώσεις ελέγχου αποδοχής πρέπει να
   αποτύχει στο υπάρχον λογισμικό. Η ύπαρξη τουλάχιστον μιας αποτυχημένης
   περίπτωσης ελέγχου δίνει στον ή στους μηχανικούς λογισμικού την άδεια να
   δημιουργήσουν ή να τροποποιήσουν τον κώδικα παραγωγής ώστε να περάσει όλες
   τις συμφωνηθέντες περιπτώσεις ελέγχου. Αυτό το βήμα μπορεί να απαιτήσει
   αρκετές επαναλήψεις. Κατά τη διάρκεια αυτού του βήματος, ο κώδικας ενδέχεται
   να υποστεί ανακατασκευή.

Όταν όλες οι περιπτώσεις ελέγχου αποδοχής έχουν περάσει και πιθανότατα όλες οι
περιπτώσεις ελέγχου μονάδας και ολοκλήρωσης επίσης, τότε η μονάδα
λειτουργικότητας θεωρείται ότι έχει υλοποιηθεί πλήρως και σωστά. Η διαδικασία
ATDD επιστρέφει στο βήμα 1, όπου επιλέγεται μια νέα μονάδα λειτουργικότητας
και ο κύκλος επαναλαμβάνεται.

Η ATDD μπορεί να φαίνεται μια τεχνική ελέγχου αντί για μια τεχνική καθορισμού
απαιτήσεων. Από την άλλη πλευρά, μια περίπτωση ελέγχου έχει τη γενική μορφή:
"Όταν δοθεί είσοδος που μοιάζει με το X, <u>αναμένουμε το λογισμικό να
παράγει</u> αποτελέσματα που μοιάζουν με το Y." Το κλειδί είναι η υπογραμμισμένη
φράση "αναμένουμε το λογισμικό να παράγει". Εάν απλώς τροποποιήσουμε αυτήν τη
φράση για να λέει "το λογισμικό θα πρέπει να παράγει", όπως στο: "Όταν δοθεί
είσοδος που μοιάζει με το X, <u>το λογισμικό θα πρέπει να παράγει</u>
αποτελέσματα που μοιάζουν με το Y", αυτό που πρώτα φαινόταν σαν περίπτωση
ελέγχου τώρα μοιάζει με απαίτηση. Τεχνικά, μια περίπτωση ελέγχου αποδοχής
μπορεί να καλύπτει περισσότερες από μία απλές απαιτήσεις, αλλά η γενική ιδέα
είναι ότι οι περιπτώσεις ελέγχου ATDD είναι ουσιαστικά ακριβείς και ξεκάθαρες
δηλώσεις απαιτήσεων.

Η προσέγγιση της BDD είναι κάπως πιο δομημένη και οι ειδικοί στον τομέα της
επιχείρησης την προτιμούν συνήθως αντί για την ATDD επειδή έχει λιγότερο
τεχνική εμφάνιση. Στη BDD, η μονάδα λειτουργικότητας περιγράφεται ως μια
ιστορία χρήστη, σε μια μορφή όπως αυτή: "Ως ένας <ρόλος>, θέλω
<στόχος/επιθυμία> ώστε <ωφέλεια>." Αυτό οδηγεί στον εντοπισμό και τον
προσδιορισμό ενός συνόλου "σεναρίων" σε αυτήν τη μορφή: "Δεδομένου
<κάποιου πλαισίου> [και <πιθανότατα επιπλέον πλαισίου>], όταν <έναυσμα>
τότε <αποτέλεσμα> [και <πιθανότατα περισσότερα αποτελέσματα>]."

Εάν η ιστορία είναι: "Ως πελάτης της τράπεζας, θέλω να κάνω ανάληψη χρημάτων
από το Αυτόματο Μηχάνημα Ανάληψης (ATM) ώστε να μπορώ να πάρω χρήματα χωρίς να
πηγαίνω στην τράπεζα", ένα σενάριο θα μπορούσε να είναι ότι "ο λογαριασμός έχει
ικανοποιητικό υπόλοιπο". Αυτό το σενάριο θα μπορούσε να παρουσιαστεί λεπτομερώς
ως εξής: "Δεδομένου ότι το υπόλοιπο του λογαριασμού είναι $500 και η τραπεζική
κάρτα του πελάτη είναι έγκυρη και το Αυτόματο Μηχάνημα Ανάληψης περιέχει αρκετά
χρήματα στο κουτί του, όταν ο κάτοχος λογαριασμού ζητά $100, τότε το ATM θα
πρέπει να βγάλει $100 και το υπόλοιπο του λογαριασμού θα πρέπει να είναι $400
και η τραπεζική κάρτα του πελάτη θα πρέπει να επιστραφεί".

Ένα άλλο σενάριο μπορεί να είναι ότι "ο λογαριασμός έχει ανεπαρκή υπόλοιπο" και
μπορεί να αναλυθεί ως εξής: "Δεδομένου ότι το υπόλοιπο του λογαριασμού είναι
$50 και η κάρτα του πελάτη είναι έγκυρη και το Αυτόματο Μηχάνημα Ανάληψης
περιέχει αρκετά χρήματα στο κουτί του, όταν ο κάτοχος του λογαριασμού ζητά
$100, τότε το ATM δεν πρέπει να εκδώσει χρήματα, και θα πρέπει να εμφανίσει ένα
μήνυμα ότι υπάρχει ανεπαρκές υπόλοιπο, το υπόλοιπο θα πρέπει να παραμείνει στα
$50 και η κάρτα του πελάτη θα πρέπει να επιστραφεί."

Ο στόχος της BDD είναι να υπάρχει ένα εμπεριστατωμένο σύνολο σεναρίων για κάθε
μονάδα λειτουργικότητας. Στην περίπτωση της ανάληψης μετρητών, θα χρειαζόταν
επιπλέον σενάρια για το "Η κάρτα του τραπεζικού πελάτη έχει απενεργοποιηθεί"
και το "Το ΑΤΜ δεν περιέχει αρκετά χρήματα στο κουτί του".

Οι περιπτώσεις ελέγχου αποδοχής είναι φανερές από τα σενάρια της BDD.

Ο προσδιορισμός απαιτήσεων που βασίζεται σε κριτήρια αποδοχής αντιμετωπίζει
άμεσα το πρόβλημα της ασάφειας των απαιτήσεων. Οι φυσικές γλώσσες είναι
από τη φύση τους αόριστες, αλλά η γλώσσα των περιπτώσεων ελέγχου δεν είναι.
Στον προσδιορισμό απαιτήσεων που βασίζεται σε κριτήρια αποδοχής, οι απαιτήσεις
γράφονται χρησιμοποιώντας τη γλώσσα των περιπτώσεων ελέγχου, η οποία είναι πολύ
ακριβής. Από την άλλη πλευρά, αυτό δεν λύνει από μόνο του το πρόβλημα της
έλλειψης πληρότητας. Ωστόσο, η συνδυασμένη χρήση της ATDD ή BDD με κατάλληλα
κριτήρια κάλυψης λειτουργικότητας, όπως ο έλεγχος πεδίου, η ανάλυση
ακραίων τιμών και τα ζεύγη ελέγχου (βλ. το γνωστικό πεδίο Έλεγχος
Λογισμικού), μπορεί να μειώσει την πιθανότητα μη πληρότητας των απαιτήσεων.

### *Προσδιορισμός απαιτήσεων βασισμένος σε μοντέλο*

Μια άλλη προσέγγιση για την αποφυγή της εγγενούς ασάφειας των φυσικών
γλωσσών είναι η χρήση γλωσσών μοντελοποίησης, όπως επιλεγμένα στοιχεία της
Ενοποιημένη Γλώσσα Μοντελοποίησης (UML) ή της γλώσσας μοντελοποίησης συστημάτων
(SysML). Όπως οι σχεδιαγράμματα που χρησιμοποιούνται στην κατασκευή κτιρίων,
έτσι και αυτές οι γλώσσες μοντελοποίησης μπορούν να χρησιμοποιηθούν με έναν
τρόπο που είναι ανεξάρτητος από την τεχνολογία υπολογιστών για να καθορίσουν με
ακρίβεια και συνοπτικότητα τις λειτουργικές απαιτήσεις. Αυτό το θέμα σχετίζεται
στενά με το γνωστικό πεδίο Μοντέλα και Μέθοδοι Μηχανικής Λογισμικού.
Τα μοντέλα απαιτήσεων εμπίπτουν σε δύο γενικές κατηγορίες:

1. Δομικά μοντέλα για τον καθορισμό των πολιτικών που πρέπει να επιβάλλονται:
Αυτά είναι λογικά μοντέλα κλάσης. Επίσης ονομάζονται εννοιολογικά μοντέλα
δεδομένων και διαγράμματα οντοτήτων-συσχετίσεων.
2. Μοντέλα συμπεριφοράς για τον καθορισμό των διαδικασιών που πρέπει να
πραγματοποιηθούν: Αυτά τα μοντέλα περιλαμβάνουν μοντελοποίηση περιπτώσεων
χρήσης, τα διαγράμματα αλληλεπίδρασης και καταστατική μοντελοποίηση.
Άλλα παραδείγματα είναι τα διαγράμματα δραστηριοτήτων σε UML και
η μοντελοποίηση ροής δεδομένων, όπως περιγράφεται στα [8], [10] και [18].

Οι προδιαγραφές απαιτήσεων βασισμένες σε μοντέλο διαφέρουν στο βαθμό
της μοντελοποίησης. Ας λάβουμε υπόψη τα εξής:

* Η ευέλικτη μοντελοποίηση (Agile modeling) (βλ. για παράδειγμα [10]) είναι το
λιγότερο τυπικό. Τα ευέλικτα μοντέλα μπορεί να είναι κάτι λίγο παραπάνω από
πρόχειρα σχεδιαγράμματα των οποίων ο στόχος είναι να επικοινωνήσουν σημαντικές
πληροφορίες αντί να δείξουν τη σωστή χρήση των σημειογραφιών μοντελοποίησης.
Σε αυτόν τον τύπο μοντελοποίησης, το αποτέλεσμα της επικοινωνίας θεωρείται πιο
σημαντικό από τη μορφή της επικοινωνίας.
* Η ημιεπίσημη μοντελοποίηση, παρέχει έναν ορισμό των σημασιολογικών στοιχείων
της γλώσσας μοντελοποίησης, αλλά αυτός ο ορισμός δεν έχει αποδειχθεί επίσημα
ότι είναι πλήρης και συνεπής.
* Η μοντελοποίηση με τη χρήση τυπικών μεθόδων, όπως η Ζ, η Μέθοδος Ανάπτυξης
της Βιέννης (Vienna Development Method ή VDM), η Γλώσσα Περιγραφής και
Προδιαγραφής (SDL) διαθέτουν πολύ ακριβώς καθορισμένη σημασιολογία που
επιτρέπει την μηχανική ανάλυση των προδιαγραφών για την παρουσία ή την απουσία
συγκεκριμένων ιδιοτήτων, προκειμένου να βοηθήσουν στην αποφυγή κρίσιμων λαθών
στον συλλογισμό. Ο όρος *ορθότητα εκ κατασκευής* (correctness by construction)
χρησιμοποιείται σε αυτό το πλαίσιο ανάπτυξης.
(βλ. την ενότητα Τυπικές Μέθοδοι
στην ενότητα Μοντέλα και Μέθοδοι Μηχανικής Λογισμικού.)

Γενικά, όσο πιο τυπικό είναι ένα μοντέλο απαιτήσεων, τόσο λιγότερο
αόριστο είναι, οπότε οι μηχανικοί λογισμικού έχουν λιγότερες πιθανότητες
να παρερμηνεύσουν τις απαιτήσεις. Τα πιο φορμαλιστικά μοντέλα απαιτήσεων
μπορούν επίσης:

* να είναι πιο συνοπτικά και συμπαγή,
* να είναι πιο εύκολα μεταφράσιμα σε κώδικα, ενδεχομένως
μηχανικά,
* να χρησιμοποιηθούν ως βάση για την παραγωγή των
περιπτώσεων ελέγχου αποδοχής.

Ένα σημαντικό μήνυμα είναι ότι, ενώ οι τυπικές γλώσσες
μοντελοποίησης είναι πιο δυνατές από τις ημιεπίσημες και ευέλικτες
μοντελοποιήσεις, οι τυπικές σημειογραφίες μπορούν να επιβαρύνουν τόσο τον
δημιουργό του μοντέλου όσο και τους ανθρώπους που το διαβάζουν.
Η συμβιβαστική λύση της Wing είναι η χρήση τυπικά
καθορισμένων βάσεων (π.χ. στη Z) για επιφανειακό συντακτικό που
είναι πιο εύκολο στην ανάγνωση και την γραφή (π.χ. καταστατικά διαγράμματα UML).

### *Περαιτέρω ιδιότητες των απαιτήσεων*

Πέρα από τις βασικές δηλώσεις απαιτήσεων που έχουν ήδη περιγραφεί, η
τεκμηρίωση πρόσθετων χαρακτηριστικών για ορισμένες ή όλες τις απαιτήσεις
μπορεί να είναι χρήσιμη. Αυτές οι συμπληρωματικές λεπτομέρειες μπορούν να
βοηθήσουν τους μηχανικούς λογισμικού να ερμηνεύσουν και να διαχειριστούν
καλύτερα τις απαιτήσεις. Πιθανά επιπλέον χαρακτηριστικά περιλαμβάνουν τα εξής:

* ετικέτα για υποστήριξη της ιχνηλασιμότητας των απαιτήσεων,
* περιγραφή (περισσότερες λεπτομέρειες για την απαίτηση),
* αιτιολογία (γιατί η απαίτηση είναι σημαντική),
* πηγή (ρόλος ή όνομα του ενδιαφερόμενου μέρους που επέβαλε αυτήν την
απαίτηση),
* περίπτωση χρήσης ή σχετικού γεγονότος που δίνει το έναυσμα,
* τύπος (ταξινόμηση ή κατηγορία της απαίτησης - για παράδειγμα, λειτουργική,
ποιότητα υπηρεσίας),
* εξαρτήσεις,
* αντιθέσεις,
* κριτήρια αποδοχής,
* προτεραιότητα (βλ. Ιεράρχηση απαιτήσεων αργότερα στο παρόν γνωστικό πεδίο),
* σταθερότητα (βλ. Σταθερότητα και μεταβλητότητα απαιτήσεων
αργότερα στο παρόν γνωστικό πεδίο),
* εάν η απαίτηση είναι κοινή ή μια παραλλαγή για την ανάπτυξη οικογένειας
προϊόντων),
* υλικά υποστήριξης,
* ιστορικό αλλαγών της απαίτησης.

Η Γλώσσα Πλάνου (Planguage) του Gilb [7] συνιστά χαρακτηριστικά όπως
κλίμακα, μέτρο, ελάχιστο, στόχος, εξαίρετο, παρελθόν, τάση και αρχείο.


## Επικύρωση απαιτήσεων {#validreq}

Τα έγγραφα απαιτήσεων μπορούν να υπόκεινται σε διαδικασίες επικύρωσης
και επαλήθευσης. Οι απαιτήσεις μπορεί να επικυρώνονται, για να εξασφαλίζουν
ότι ο μηχανικός λογισμικού τις έχει κατανοήσει. Είναι επίσης σημαντικό
να εξακριβώνεται ότι ένα έγγραφο απαιτήσεων συμμορφώνεται στα πρότυπα
της εταιρείας και ότι είναι κατανοητό, συνεπές και πλήρες.
Σε περιπτώσεις, όπου τεκμηριωμένα πρότυπα ή η ορολογία της εταιρείας
είναι ασυμβίβαστα με ευρέως αποδεκτά πρότυπα, θα πρέπει να συμφωνηθεί
μια χαρτογράφηση μεταξύ των δύο και να επισυνάπτεται στο έγγραφο.

Οι τυπικοί συμβολισμοί προσφέρουν το σημαντικό πλεονέκτημα να επιτρέπεται
στις τελευταίες δύο ιδιότητες να αποδειχθούν (έστω και περιορισμένα).
Διαφορετικά ενδιαφερόμενα μέρη, συμπεριλαμβανομένων των εκπροσώπων
του πελάτη και του υλοποιητή, θα πρέπει να επανεξετάσουν το έγγραφο
(ή τα έγγραφα). Τα έγγραφα απαιτήσεων υπόκεινται στις ίδιες πρακτικές
διαχείρισης διαμόρφωσης με τα άλλα παραδοτέα των διεργασιών του κύκλου
ζωής του λογισμικού. Όταν είναι εφικτό, οι επιμέρους απαιτήσεις επίσης
υπόκεινται σε διαχείριση της διαμόρφωσης, γενικώς χρησιμοποιώντας
ένα εργαλείο διαχείρισης απαιτήσεων (βλ. ενότητα [Εργαλεία απαιτήσεων λογισμικού](#toolsreq)).

Είναι φυσιολογικό να προγραμματιστούν ρητά ένα ή περισσότερα σημεία
της διαδικασίας απαιτήσεων, όπου οι απαιτήσεις έχουν επικυρωθεί. Ο
στόχος είναι να διευθετηθούν τυχόν προβλήματα, προτού διατεθούν πόροι
για την εφαρμογή των απαιτήσεων.
Η επικύρωση απαιτήσεων ασχολείται με τη διαδικασία εξέτασης του εγγράφου
απαιτήσεων, για να διασφαλιστεί ότι καθορίζεται το σωστό λογισμικό
(δηλαδή, το λογισμικό για το οποίο οι χρήστες προσδοκούν).

### Επιθεώρηση απαιτήσεων {#review-req}


Ίσως το πιο κοινό μέσο επικύρωσης γίνεται με την επιθεώρηση ή τα σχόλια
του εγγράφου (ή εγγράφων) απαιτήσεων. Σε μια ομάδα επιθεωρητών αποδίδεται
η έρευνα για λάθη, λανθασμένες παραδοχές, η έλλειψη σαφήνειας και
απόκλιση από την καθιερωμένη πρακτική.
Η σύνθεση της ομάδας, που διεξάγει την επιθεώρηση, είναι σημαντική
(για παράδειγμα, θα πρέπει να περιλαμβάνει, τουλάχιστον, έναν εκπρόσωπο
του πελάτη για ένα έργο, που βασίζεται στον πελάτη), και μπορεί να
βοηθήσει στην καθοδήγηση σχετικά με το τι πρέπει να διερευνηθεί για
τη μορφή των καταλόγων ελέγχου.

Οι επιθεωρήσεις μπορεί να συνθέτονται κατά την ολοκλήρωση του εγγράφου
διασαφήνισης του συστήματος, του εγγράφου καθορισμού του συστήματος,
του εγγράφου καθορισμού των απαιτήσεων λογισμικού, του καθορισμού
της αναφοράς για μια νέα έκδοση ή σε οποιοδήποτε άλλο στάδιο της διαδικασίας.

### Υλοποίηση πρωτοτύπου {#prototyping}

Η υλοποίηση πρωτοτύπου είναι συνήθως ένα μέσο για την επικύρωση της
ερμηνείας των απαιτήσεων του λογισμικού από το μηχανικό λογισμικού,
καθώς και για την εκμαίευση νέων απαιτήσεων. Όπως και στην εκμαίευση,
υπάρχει μια σειρά τεχνικών υλοποίησης πρωτοτύπων και μια σειρά από
σημεία της διαδικασίας, όπου η επικύρωση του πρωτοτύπου  μπορεί να
είναι χρήσιμη. Το πλεονέκτημα των πρωτοτύπων είναι ότι μπορούν να
κάνουν ευκολότερη την ερμηνεία των παραδοχών από το μηχανικό λογισμικού
και, όπου κρίνεται απαραίτητο, να «επιστρέψει» πληροφορίες ως προς
το γιατί αυτές μπορεί να είναι λάθος. Για παράδειγμα, η δυναμική συμπεριφορά
της διεπαφής του χρήστη μπορεί να γίνει καλύτερα κατανοητή μέσω ενός
κινούμενου πρωτότυπου παρά μέσω της περιγραφής κειμένου ή γραφικών
μοντέλων. Η μεταβλητότητα της απαίτησης, που διασαφηνίζεται μετά την
υλοποίηση πρωτοτύπου, έχει γίνει είναι εξαιρετικά χαμηλή, διότι δεν
υπάρχει συμφωνία μεταξύ των ενδιαφερόμενων μερών και του μηχανικού
λογισμικού - ως εκ τούτου, τα κρίσιμα για την ασφάλεια και τα καίρια
χαρακτηριστικά υλοποίησης πρωτοτύπου θα μπορούσαν πραγματικά να βοηθήσουν.
Όμως, υπάρχουν μειονεκτήματα. Αυτά περιλαμβάνουν τον κίνδυνο της απόσπασης
της προσοχής των χρηστών από τον πυρήνα της βαθύτερης λειτουργικότητας,
λόγω προβλημάτων αισθητικής ή  ποιότητας του πρωτοτύπου. Τα πρωτότυπα
μπορεί να είναι δαπανηρά για να αναπτυχθούν. Ωστόσο, εάν αποφευχθεί
η σπατάλη πόρων, που προκαλείται από την προσπάθεια να ικανοποιηθούν
λανθασμένες απαιτήσεις, το κόστος τους μπορεί να δικαιολογηθεί πιο
εύκολα. Τα αρχικά πρωτότυπα μπορούν να περιέχουν στοιχεία του τελικού
προϊόντος.
Τα πρωτότυπα μπορεί να είναι εξελικτικά και όχι μιας χρήσης.

### Επικύρωση του μοντέλου {#valid-model-req}

Είναι συνήθως απαραίτητο να επικυρώνεται η ποιότητα των μοντέλων,
που αναπτύχθηκαν κατά τη διάρκεια της ανάλυσης. Για παράδειγμα, στα
μοντέλα αντικειμένων είναι χρήσιμο να εκτελείται μια στατική ανάλυση,
για να εξακριβωθεί ότι υπάρχουν δίαυλοι επικοινωνίας μεταξύ των αντικειμένων
που ανταλλάσσουν δεδομένα, στο πεδίο των ενδιαφερομένων μερών. Εάν
χρησιμοποιούνται συμβολισμοί τυπικής ανάλυσης, είναι δυνατόν να χρησιμοποιηθεί
η επίσημη αιτιολόγηση για να αποδειχθούν οι ιδιότητες των προδιαγραφών.
Το θέμα αυτό συνδέεται στενά με το γνωστικό πεδίο Μοντέλα και μέθοδοι τεχνολογίας 
λογισμικού.

### Έλεγχοι αποδοχής {#accept-testing}


Μια βασική ιδιότητα μιας απαίτησης λογισμικού είναι ότι πρέπει να
είναι δυνατό να επαληθευτεί πως το τελικό προϊόν την ικανοποιεί. Απαιτήσεις,
οι οποίες δε μπορούν να επικυρωθούν, στην πραγματικότητα είναι απλά
«ευχές». Συνεπώς, μία σημαντική εργασία είναι να προβλέπεται πώς θα
ελέγχεται κάθε απαίτηση.
Στις περισσότερες περιπτώσεις, ο σχεδιασμός δοκιμών αποδοχής κάνει
αυτό για το οποίο οι τελικοί χρήστες χρησιμοποιούν το σύστημα
κατά κανόνα δεοντολογίας των επιχειρήσεων.

Ο καθορισμός και ο σχεδιασμός ελέγχων αποδοχής μπορεί να είναι δύσκολοι
για τις μη λειτουργικές απαιτήσεις (βλ. παράγραφο [Λειτουργικές
και μη λειτουργικές απαιτήσεις](#func-nonfun-req)).
Για να επικυρωθούν, πρέπει πρώτα να αναλυθούν και να αποσυντεθούν
σε σημείο να μπορούν να εκφράζονται ποσοτικά.

Πρόσθετες πληροφορίες μπορείτε να βρείτε στο θέμα Έλεγχος αποδοχής/πιστοποίησης
στο γνωστικό πεδίο Έλεγχος λογισμικού.

## Πρακτικές θεωρήσεις

Το πρώτο επίπεδο του θέματος αποσύνθεσης, που παρουσιάζεται σε αυτό
το γνωστικό πεδίο, μπορεί να φαίνεται να περιγράφει μια γραμμική αλληλουχία
των δραστηριοτήτων.
Αυτή είναι μια απλοποιημένη όψη της διαδικασίας.

Η διεργασία προδιαγραφής των  απαιτήσεων καλύπτει ολόκληρο τον κύκλο
ζωής του λογισμικού.
Η αλλαγή διαχείρισης και της συντήρησης των απαιτήσεων σε μια κατάσταση,
που αντικατοπτρίζει με ακρίβεια το λογισμικό που πρόκειται να υλοποιηθεί
ή που έχει υλοποιηθεί, είναι το κλειδί για την επιτυχία της διαδικασίας
ανάπτυξης λογισμικού.

Δεν έχει κάθε οργανισμός μια κουλτούρα καταγραφής και διαχείρισης
των απαιτήσεων. Είναι σύνηθες σε δυναμικές νεοσύστατες εταιρείες,
ωθούμενες από ένα ισχυρό «όραμα του προϊόντος» και με περιορισμένους
πόρους, για να αντιμετωπίζουν την τεκμηρίωση των απαιτήσεων ως περιττή
επιβάρυνση. Τις περισσότερες φορές, όμως, καθώς οι εταιρείες επεκτείνονται,
η πελατειακή τους βάση αυξάνεται και το προϊόν τους αρχίζει να εξελίσσεται,
ανακαλύπτουν ότι θα χρειαστεί να ανακτήσουν τις απαιτήσεις που εκμαίευσαν
τα χαρακτηριστικά του προϊόντος, προκειμένου να εκτιμηθεί το αντίκτυπο
των προτεινόμενων αλλαγών.
Ως εκ τούτου, η τεκμηρίωση των απαιτήσεων και η διαχείρισης της αλλαγής
είναι το κλειδί της επιτυχίας οποιασδήποτε διεργασίας προδιαγραφής
των  απαιτήσεων.

### Επαναληπτικός χαρακτήρας της διεργασίας  απαιτήσεων

Υπάρχει μια γενική πίεση στη βιομηχανία λογισμικού για συνεχώς μικρότερους
κύκλους ανάπτυξης, και αυτό είναι ιδιαίτερα έντονο σε εξαιρετικά ανταγωνιστικά
τμήματα της αγοράς. Επιπλέον, τα περισσότερα έργα περιορίζονται κατά
κάποιο τρόπο από το περιβάλλον τους, και πολλά από αυτά είναι αναβαθμίσεις
ή αναθεωρήσεις υπάρχοντος λογισμικού, των οποίων η αρχιτεκτονική είναι
γνωστή. Ως εκ τούτου, στην πράξη είναι σχεδόν πάντα ανέφικτο να εφαρμοστεί
η διεργασία προδιαγραφής απαιτήσεων ως μια γραμμική, ντετερμινιστική
διαδικασία, στην οποία οι απαιτήσεις του λογισμικού εκμαιεύονται από
τα ενδιαφερόμενα μέρη, αρχικοποιούνται, κατανέμονται και παραδίδονται
στην ομάδα ανάπτυξης του λογισμικού.
Είναι σίγουρα ένας μύθος ότι οι απαιτήσεις για τα μεγάλα έργα λογισμικού
είναι πάντα απόλυτα κατανοητές ή καθορισμένες ολόσωστα.

Αντ' αυτού, οι απαιτήσεις συνήθως επαναλαμβάνονται ως προς ένα επίπεδο
ποιότητας και λεπτομέρειας, που είναι επαρκές προκειμένου να επιτραπεί
ο σχεδιασμός και η λήψη των αποφάσεων που πρέπει να παρθούν. Σε ορισμένα
έργα, αυτό μπορεί να οδηγήσει σε απαιτήσεις που αρχικοποιούνται πριν
να γίνουν πλήρως κατανοητές όλες οι ιδιότητές τους. Αυτό εγκυμονεί
κινδύνους για ακριβές επαναλήψεις, αν προκύψουν προβλήματα αργά στη
διαδικασία της υλοποίησης λογισμικού. Ωστόσο, οι μηχανικοί λογισμικού
περιορίζονται αναγκαστικά από τα σχέδια διαχείρισης του έργου. Επομένως,
πρέπει να λάβουν μέτρα για να διασφαλιστεί, ότι η «ποιότητα» των απαιτήσεων
είναι όσο το δυνατόν υψηλότερη σε σχέση τους διαθέσιμους πόρους.
Για παράδειγμα, θα πρέπει να κάνουν ρητές τυχόν παραδοχές, στις οποίες
στηρίζονται οι απαιτήσεις, καθώς και τυχόν γνωστά προβλήματα.

Για τα προϊόντα λογισμικού, που έχουν αναπτυχθεί επαναληπτικά, μπορεί
μια ομάδα του έργου να αρχικοποιήσει μόνο τις απαιτήσεις που είναι
αναγκαίες για την τρέχουσα επανάληψη. Ο ειδικός απαιτήσεων μπορεί
να συνεχίσει να δημιουργεί απαιτήσεις για τις μελλοντικές επαναλήψεις,
ενώ οι προγραμματιστές προχωρούν με το σχεδιασμό και την κατασκευή
της τρέχουσας επανάληψης.
Αυτή η προσέγγιση παρέχει στους πελάτες την επιχειρηματική αξία γρήγορα,
ελαχιστοποιώντας παράλληλα το κόστος επανάληψης.

Σε όλες σχεδόν τις περιπτώσεις, η κατανόηση των απαιτήσεων συνεχίζει
να εξελίσσεται καθώς ο σχεδιασμός και η ανάπτυξη προχωρούν. Αυτό συχνά
οδηγεί στην αναθεώρηση των απαιτήσεων αργά στον κύκλο ζωής. Ίσως το
πιο καίριο σημείο για την κατανόηση των απαιτήσεων του λογισμικού
είναι ότι ένα σημαντικό ποσοστό των απαιτήσεων θα αλλάξει. Αυτό μερικές
φορές οφείλεται σε λάθη της ανάλυσης, αλλά είναι συχνά μια αναπόφευκτη
συνέπεια της αλλαγής στο «περιβάλλον», για παράδειγμα, το λειτουργικό
ή επιχειρηματικό περιβάλλον του πελάτη, τις ρυθμιστικές διαδικασίες,
που επιβάλλονται από τις αρχές, ή την αγορά στην οποία το λογισμικό
πρέπει να πουληθεί. Όποια και αν είναι η αιτία, είναι σημαντικό να
αναγνωρίσουμε το αναπόφευκτο των αλλαγών και να λάβουμε μέτρα για
την άμβλυνση των συνεπειών τους. Η αλλαγή πρέπει να είναι διαχωρίσιμη
έτσι, ώστε να διασφαλίζει, ότι οι προτεινόμενες αλλαγές θα περάσουν
από μια ορισμένη επιθεώρηση και μια διαδικασία έγκρισης, και να πραγματοποιείται
προσεκτικός εντοπισμός των απαιτήσεων, ανάλυση των επιπτώσεων, καθώς
και διαχείριση των σχηματισμών του λογισμικού (βλ. στο γνωστικό πεδίο
[Διαχείριση σχηματισμών λογισμικού](#softconfigmng)). Ως εκ τούτου, η διεργασία προδιαγραφή
των  απαιτήσεων δεν είναι απλώς ένα μετωπικό εφάπαξ έργο στην ανάπτυξη
λογισμικού, αλλά εκτείνεται σε ολόκληρο τον κύκλο ζωής του λογισμικού.
Σε ένα τυπικό έργο, οι δραστηριότητες, που σχετίζονται με τις απαιτήσεις
του λογισμικού, εξελίσσονται με την πάροδο του χρόνου μέσω της διαχείρισης
των αλλαγών. Ένας συνδυασμός των άνω προς τα κάτω μεθόδων ανάλυσης
και σχεδιασμού και των από κάτω προς τα πάνω μεθόδων υλοποίησης που
συναντιούνται στη μέση, θα μπορούσε να προσφέρει το καλύτερο και στους
δύο κόσμους.
Ωστόσο, αυτό είναι δύσκολο να επιτευχθεί στην πράξη, δεδομένου ότι
εξαρτάται σε μεγάλο βαθμό από την ωριμότητα και την εμπειρία των μηχανικών
λογισμικού.

### Διαχείριση αλλαγής

Η διαχείριση της αλλαγής είναι βασική για την διαχείριση των απαιτήσεων.
Αυτό το θέμα περιγράφει το ρόλο της διαχείρισης της αλλαγής, τις διαδικασίες
που πρέπει να πραγματοποιηθούν και την ανάλυση, που πρέπει να εφαρμόζεται
για τις προτεινόμενες αλλαγές.
Έχει ισχυρούς δεσμούς με το γνωστικό πεδίο Διαχείριση σχηματισμών 
λογισμικού.

### Γνωρίσματα απαιτήσεων {#attribreq}

Οι απαιτήσεις θα πρέπει να αποτελούνται όχι μόνο από μια προδιαγραφή
του τι απαιτείται, αλλά και της συμπληρωματικής πληροφορίας, η οποία
βοηθά στην διαχείριση και την ερμηνεία τους. Τα γνωρίσματα των απαιτήσεων
πρέπει να καθορίζονται, να καταγράφονται και να ενημερώνονται καθώς
το λογισμικό υπό ανάπτυξη ή υπό συντήρηση εξελίσσεται. Αυτό θα πρέπει
να περιλαμβάνει τις διάφορες κατηγοριοποιήσεις των διαστάσεων των
απαιτήσεων (βλ. παράγραφο [Κατηγοριοποίηση απαιτήσεων](#classif-req)) και τη
μέθοδο επαλήθευσης ή το σχετικό πλάνο ελέγχου αποδοχής.  Μπορεί επίσης
να περιλαμβάνει πρόσθετες πληροφορίες, όπως μία σύνοψη αιτιολόγησης
για κάθε απαίτηση, την πηγή της κάθε απαίτησης, και ένα ιστορικό αλλαγής.
Το πιο σημαντικό  γνώρισμα των απαιτήσεων, ωστόσο, είναι ένα προσδιοριστικό,
το οποίο επιτρέπει οι απαιτήσεις να είναι μοναδικές και να προσδιορίζονται
σαφώς.

### Ιχνηλασιμότητα απαιτήσεων {#tr-req}

Η ιχνηλασιμότητα των απαιτήσεων ασχολείται με την ανάκτηση της πηγής
τους και την πρόβλεψη των επιδράσεών τους. Η ιχνηλασιμότητα είναι
θεμελιώδους σημασίας για την πραγματοποίηση της ανάλυσης των επιπτώσεων,
όταν αλλάζουν οι απαιτήσεις. Μια απαίτηση θα πρέπει να είναι ανιχνεύσιμη
προς τα πίσω στις απαιτήσεις και στα ενδιαφερόμενα μέρη, τα οποία
την διαμόρφωσαν (για παράδειγμα, από την απαίτηση του λογισμικού πίσω
στην απαίτηση του συστήματος, που βοηθά στην ικανοποίηση).
Αντίθετα, μια απαίτηση θα πρέπει να είναι ανιχνεύσιμη προς τα εμπρός
στις απαιτήσεις και τις οντότητες σχεδιασμού, τα οποία την ικανοποιούν
(για παράδειγμα, από την απαίτηση του συστήματος στις απαιτήσεις του
λογισμικού, οι οποίες έχουν προκύψει από την πρώτη, και, εν συνεχεία,
στις ενότητες κώδικα, που την εφαρμόζουν, ή στις περιπτώσεις δοκιμών,
που σχετίζονται με τον εν λόγω κώδικα, και ακόμη και σε ένα τμήματος
του εγχειριδίου χρήσης, που περιγράφει την πραγματική λειτουργικότητα)
και την περίπτωση δοκιμής, που την επαληθεύει.

Η ιχνηλασιμότητα των απαιτήσεων για ένα τυπικό έργο θα σχηματίσει
μια πολύπλοκη, κατευθυνόμενη, άκυκλη γραφική παράσταση. Η διατήρηση
ενός ενημερωμένου γραφήματος ή μιας μήτρας ιχνηλασιμότητας είναι μια
δραστηριότητα, που πρέπει να εξετάζεται κατά τη διάρκεια ολόκληρου
του κύκλου ζωής ενός προϊόντος.
Εάν οι πληροφορίες ιχνηλασιμότητας δεν ενημερώνονται, καθώς οι αλλαγές
στις απαιτήσεις εξακολουθούν να συμβαίνουν, οι πληροφορίες ιχνηλασιμότητας
γίνονται αναξιόπιστες για την ανάλυση των επιπτώσεων.

### Μέτρηση απαιτήσεων

Ως ένα πρακτικό θέμα, είναι συνήθως χρήσιμο να υπάρχει κάποια ιδέα
του «όγκου» των απαιτήσεων για ένα συγκεκριμένο προϊόν λογισμικού.
Ο αριθμός αυτός είναι χρήσιμος στην αξιολόγηση του «μεγέθους» μιας
αλλαγής στις απαιτήσεις, στην εκτίμηση του κόστους μιας εργασίας ανάπτυξης
ή συντήρησης ή απλώς για να χρησιμεύσει ως παρονομαστής σε άλλες μετρήσεις.
Η λειτουργική μέτρηση του μεγέθους (Functional size measurement  -
FSM) είναι μια τεχνική για την αξιολόγηση του μεγέθους του σώματος
των λειτουργικών απαιτήσεων.

Πρόσθετες πληροφορίες σχετικά με τη μέτρηση και τα πρότυπα μεγέθους
θα βρεθούν στο γνωστικό πεδίο Διοίκησης τεχνολογίας λογισμικού.

## Εργαλεία απαιτήσεων λογισμικού {#toolsreq}

Τα εργαλεία για την αντιμετώπιση των απαιτήσεων λογισμικού εμπίπτουν
γενικά σε δύο κατηγορίες: εργαλεία για την μοντελοποίηση και εργαλεία
για τη διαχείριση των απαιτήσεων.

Τα εργαλεία διαχείρισης απαιτήσεων υποστηρίζουν συνήθως ένα ευρύ φάσμα
δραστηριοτήτων - συμπεριλαμβανομένης της τεκμηρίωσης, της ιχνηλασιμότητας
και της διαχείρισης της αλλαγής - και έχουν σημαντικό αντίκτυπο στην
πράξη. Πράγματι, η ιχνηλασιμότητα και η διαχείριση της αλλαγής είναι
πραγματικά εφικτή, μόνο αν υποστηρίζεται από ένα εργαλείο.
Δεδομένου ότι η διαχείριση των απαιτήσεων είναι θεμελιώδους σημασίας
για την καλή πρακτική απαιτήσεων, πολλοί οργανισμοί έχουν επενδύσει
σε εργαλεία διαχείρισης απαιτήσεων, αν και πολλοί περισσότεροι διαχειρίζονται
τις απαιτήσεις τους με περισσότερες «επί τούτου» και γενικά λιγότερο
ικανοποιητικές λύσεις, για παράδειγμα  χρησιμοποιώντας υπολογιστικά
φύλλα.
